
=== .dockerignore ===

**/.classpath
**/.dockerignore
**/.env
**/.git
**/.gitignore
**/.project
**/.settings
**/.toolstarget
**/.vs
**/.vscode
**/*.*proj.user
**/*.dbmdl
**/*.jfm
**/azds.yaml
**/bin
**/charts
**/docker-compose*
**/Dockerfile*
**/node_modules
**/npm-debug.log
**/obj
**/secrets.dev.yaml
**/values.dev.yaml
LICENSE
README.md
!**/.gitignore
!.git/HEAD
!.git/config
!.git/packed-refs
!.git/refs/heads/**

=== .env ===

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ RabbitMQ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
RABBITMQ_HOST=rabbitmq
RABBITMQ_PORT=5672
RABBITMQ_USER=guest
RABBITMQ_PASS=guest
RABBITMQ_URI=amqp://${RABBITMQ_USER}:${RABBITMQ_PASS}@${RABBITMQ_HOST}:${RABBITMQ_PORT}

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Postgres / Analysis ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
ANALYSIS_DB_HOST=postgres
ANALYSIS_DB_PORT=5432
ANALYSIS_DB_NAME=analysisdb
ANALYSIS_DB_USER=analysis
ANALYSIS_DB_PASS=analysis
ANALYSIS_DB_URI=Host=${ANALYSIS_DB_HOST};Port=${ANALYSIS_DB_PORT};Database=${ANALYSIS_DB_NAME};Username=${ANALYSIS_DB_USER};Password=${ANALYSIS_DB_PASS}

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SQL Server / Rozetka ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
ROZETKA_SQL_SERVER=sqlserver
ROZETKA_SQL_DB=rozetkadb
ROZETKA_SQL_USER=sa
ROZETKA_SQL_PASS=Your_password123
ROZETKA_SQL_URI=Server=${ROZETKA_SQL_SERVER};Database=${ROZETKA_SQL_DB};User=${ROZETKA_SQL_USER};Password=${ROZETKA_SQL_PASS};TrustServerCertificate=True

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SQL Server / History ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
HISTORY_SQL_SERVER=sqlserver
HISTORY_SQL_DB=historydb
HISTORY_SQL_USER=sa
HISTORY_SQL_PASS=Your_password123
HISTORY_SQL_URI=Server=${HISTORY_SQL_SERVER};Database=${HISTORY_SQL_DB};User=${HISTORY_SQL_USER};Password=${HISTORY_SQL_PASS};TrustServerCertificate=True

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ MongoDB ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
MONGO_URI=mongodb://mongo:27017

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Redis ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
REDIS_URI=redis:6379

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ OpenAI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
OPENAI_API_KEY=changeme
OPENAI_MODEL=gpt-4o-mini

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Tableau ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
TABLEAU_BASE_URL=https://tableau.example.com
TABLEAU_API_TOKEN=changeme
TABLEAU_SITE_ID=

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ JWT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
JWT_ISSUER=product-review
JWT_AUDIENCE=product-review-clients
JWT_SECRET=supersecret_dev_key

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Rozetka API BaseUrl ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
ROZETKA_API_BASE_URL=https://product-api.rozetka.com.ua

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ WebApp ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
API_GATEWAY_BASE_URL=http://apigateway:8080/
TABLEAU_DASHBOARD_URL=https://tableau.example.com/t/product-review/views/Dashboard1

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Rate Limiting (Gateway) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
RATE_LIMIT_PERMIT=60
RATE_LIMIT_WINDOW=60

=== docker-compose.dcproj ===

<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" Sdk="Microsoft.Docker.Sdk">
  <PropertyGroup Label="Globals">
    <ProjectVersion>2.1</ProjectVersion>
    <DockerTargetOS>Linux</DockerTargetOS>
    <DockerPublishLocally>False</DockerPublishLocally>
    <ProjectGuid>0ce36696-2dd7-45aa-9d24-f129ea7c099a</ProjectGuid>
  </PropertyGroup>
  <ItemGroup>
    <None Include="docker-compose.override.yml">
      <DependentUpon>docker-compose.yml</DependentUpon>
    </None>
    <None Include="docker-compose.yml" />
    <None Include=".dockerignore" />
  </ItemGroup>
</Project>

=== docker-compose.yml ===

services:
  # ---------- —ñ–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞ ----------
  rabbitmq:
    image: rabbitmq:3-management-alpine
    container_name: rabbitmq
    ports:
      - "5672:5672"
      - "15672:15672"
    restart: unless-stopped
    networks:
      - review-net

  postgres:
    image: postgres:16-alpine
    container_name: postgres
    environment:
      POSTGRES_DB: analysisdb
      POSTGRES_USER: analysis
      POSTGRES_PASSWORD: analysis
    volumes: [ "postgres-data:/var/lib/postgresql/data" ]
    ports: [ "5432:5432" ]
    restart: unless-stopped
    networks:
      - review-net

  sqlserver:
    image: mcr.microsoft.com/mssql/server:2022-latest
    container_name: sqlserver
    environment:
      ACCEPT_EULA: "Y"
      MSSQL_SA_PASSWORD: "Your_password123"
      MSSQL_PID: "Express"
    ports: [ "1433:1433" ]
    volumes: [ "mssql-data:/var/opt/mssql" ]
    restart: unless-stopped
    networks:
      - review-net

  mongo:
    image: mongo:7-jammy
    container_name: mongo
    ports: [ "27017:27017" ]
    volumes: [ "mongo-data:/data/db" ]
    restart: unless-stopped
    networks:
      - review-net

  redis:
    image: redis:7-alpine
    container_name: redis
    ports: [ "6379:6379" ]
    restart: unless-stopped
    networks:
      - review-net

  # ---------- –º—ñ–∫—Ä–æ—Å–µ—Ä–≤—ñ—Å–∏ ----------
  analysisservice:
    build:
      context: .
      dockerfile: AnalysisService/AnalysisService.API/Dockerfile
    env_file: .env
    environment:
      - ConnectionStrings__RabbitMQ=${RABBITMQ_URI}
      - ConnectionStrings__Postgres=${ANALYSIS_DB_URI}
      - OpenAI__ApiKey=${OPENAI_API_KEY}
      - OpenAI__Model=${OPENAI_MODEL}
    depends_on: [ rabbitmq, postgres ]
    restart: unless-stopped
    networks:
      - review-net

  historyservice:
    build:
      context: .
      dockerfile: HistoryService/HistoryService.API/Dockerfile
    env_file: .env
    environment:
      - ConnectionStrings__SqlServer=${HISTORY_SQL_URI}
    depends_on: [ sqlserver ]
    restart: unless-stopped
    networks:
      - review-net

  scraper-rozetka:
    build:
      context: .
      dockerfile: ReviewsScraper.Rozetka/Dockerfile
    env_file: .env
    environment:
      - RabbitMq__Host=${RABBITMQ_HOST}
      - RabbitMq__Username=${RABBITMQ_USER}
      - RabbitMq__Password=${RABBITMQ_PASS}
      - ConnectionStrings__SqlServer=${ROZETKA_SQL_URI}
      - RozetkaApi__BaseUrl=${ROZETKA_API_BASE_URL}
      - Cache__Redis=${REDIS_URI}
    depends_on: [ sqlserver, rabbitmq, redis ]
    restart: unless-stopped
    networks:
      - review-net

  tableauexporter:
    build:
      context: .
      dockerfile: TableauExporterService/TableauExporterService.API/Dockerfile
    env_file: .env
    environment:
      - ConnectionStrings__RabbitMQ=${RABBITMQ_URI}
      - ConnectionStrings__Mongo=${MONGO_URI}
      - Tableau__ApiToken=${TABLEAU_API_TOKEN}
      - Tableau__BaseUrl=${TABLEAU_BASE_URL}
      - Tableau__SiteId=${TABLEAU_SITE_ID}
    depends_on: [ rabbitmq, mongo ]
    restart: unless-stopped
    networks:
      - review-net

  webapp:
    build:
      context: .
      dockerfile: WebApp/Dockerfile
    env_file: .env
    environment:
      - ApiGateway__BaseUrl=${API_GATEWAY_BASE_URL}
      - Tableau__DashboardUrl=${TABLEAU_DASHBOARD_URL}
    depends_on: [ apigateway ]
    restart: unless-stopped
    networks:
      - review-net

  apigateway:
    build:
      context: .
      dockerfile: ApiGateway/Dockerfile
    env_file: .env
    environment:
      - Jwt__Issuer=${JWT_ISSUER}
      - Jwt__Audience=${JWT_AUDIENCE}
      - Jwt__Key=${JWT_SECRET}
      - RateLimiting__PermitLimit=${RATE_LIMIT_PERMIT}
      - RateLimiting__WindowSeconds=${RATE_LIMIT_WINDOW}
    ports:
      - "80:8080"
    depends_on:
      - scraper-rozetka
      - historyservice
      - analysisservice
      - tableauexporter
    restart: unless-stopped
    networks:
      - review-net

volumes:
  postgres-data:
  mssql-data:
  mongo-data:


networks:
  review-net:
    driver: bridge

=== launchSettings.json ===

{
  "profiles": {
    "Docker Compose": {
      "commandName": "DockerCompose",
      "commandVersion": "1.0",
      "serviceActions": {
        "gateway": "StartDebugging"
      }
    }
  }
}

=== ProductReviewAnalyzer.sln ===


Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.12.35527.113
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ProductReviewAnalyzer.Common", "Common\ProductReviewAnalyzer.Common.csproj", "{48A9C13D-2D4A-4349-B750-1662AB087FBE}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ProductReviewAnalyzer.ReviewsScraper.Rozetka", "ReviewsScraper.Rozetka\ProductReviewAnalyzer.ReviewsScraper.Rozetka.csproj", "{168785DF-BBAC-4360-99CB-A33F937B9504}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ProductReviewAnalyzer.ReviewsScraper.Foxtrot", "ReviewsScraper.Foxtrot\ProductReviewAnalyzer.ReviewsScraper.Foxtrot.csproj", "{86A8D6A6-0AD3-4BEA-BDA4-5EA007EE1012}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ProductReviewAnalyzer.ReviewsScraper.Allo", "ReviewsScraper.Allo\ProductReviewAnalyzer.ReviewsScraper.Allo.csproj", "{102C1C5F-051E-440F-B5E4-B3DAF006E512}"
EndProject
Project("{E53339B2-1760-4266-BCC7-CA923CBCF16C}") = "docker-compose", "docker-compose.dcproj", "{0CE36696-2DD7-45AA-9D24-F129EA7C099A}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "AnalysisService", "AnalysisService", "{2908EBB8-E348-4E02-B2EF-D874BFAFE975}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ProductReviewAnalyzer.AnalysisService.API", "AnalysisService\AnalysisService.API\ProductReviewAnalyzer.AnalysisService.API.csproj", "{09F51B30-1FA6-4A4A-87D4-D8459C0234B3}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ProductReviewAnalyzer.AnalysisService.Application", "AnalysisService\AnalysisService.Application\ProductReviewAnalyzer.AnalysisService.Application.csproj", "{22377247-BFE8-4088-95F0-B6B56BD398BC}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ProductReviewAnalyzer.AnalysisService.Domain", "AnalysisService\AnalysisService.Domain\ProductReviewAnalyzer.AnalysisService.Domain.csproj", "{C68A55FA-E958-40E0-A367-3BD61A96701D}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ProductReviewAnalyzer.AnalysisService.Infrastructure", "AnalysisService\AnalysisService.Infrastructure\ProductReviewAnalyzer.AnalysisService.Infrastructure.csproj", "{2CE2539E-1D00-428B-971D-9300D53F7AD4}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ProductReviewAnalyzer.AnalysisService.Messaging", "AnalysisService\AnalysisService.Messaging\ProductReviewAnalyzer.AnalysisService.Messaging.csproj", "{29FF9811-6470-4EF5-97CA-0BA10A9A0910}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "HistoryService", "HistoryService", "{B09774E6-B229-4BA2-BB96-B3F5E86FDAA8}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ProductReviewAnalyzer.HistoryService.API", "HistoryService\HistoryService.API\ProductReviewAnalyzer.HistoryService.API.csproj", "{B6F4E582-172C-4779-BBFC-055CD2B75F8A}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ProductReviewAnalyzer.HistoryService.Domain", "HistoryService\HistoryService.Domain\ProductReviewAnalyzer.HistoryService.Domain.csproj", "{ACB252FB-D817-412E-B782-B9858C2DEC1B}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ProductReviewAnalyzer.HistoryService.Application", "HistoryService\HistoryService.Application\ProductReviewAnalyzer.HistoryService.Application.csproj", "{EEE074DB-1F1F-4372-B9E0-733698E04DA3}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ProductReviewAnalyzer.HistoryService.Infrastructure", "HistoryService\HistoryService.Infrastructure\ProductReviewAnalyzer.HistoryService.Infrastructure.csproj", "{E2ED5FB8-B7B2-4446-9B3F-65B0305E765A}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "TableauExporterService", "TableauExporterService", "{17CF8952-EE54-4C9F-81D3-2D59A67383C0}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ProductReviewAnalyzer.TableauExporterService.API", "TableauExporterService\TableauExporterService.API\ProductReviewAnalyzer.TableauExporterService.API.csproj", "{58F70C4C-0039-4904-90F7-5AA25A41569F}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ProductReviewAnalyzer.TableauExporterService.Infrastructure", "TableauExporterService\TableauExporterService.Infrastructure\ProductReviewAnalyzer.TableauExporterService.Infrastructure.csproj", "{741FDA23-53C5-49F4-84BF-65380BD2A491}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ProductReviewAnalyzer.WebApp", "WebApp\ProductReviewAnalyzer.WebApp.csproj", "{ECF84838-DB89-4B67-BEBD-2F9E47BCB399}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ProductReviewAnalyzer.ApiGateway", "ApiGateway\ProductReviewAnalyzer.ApiGateway.csproj", "{487E19A7-A050-4129-BFA3-47F7045AE616}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ProductReviewAnalyzer.TableauExporterService.Features", "TableauExporterService\TableauExporterService.Features\ProductReviewAnalyzer.TableauExporterService.Features.csproj", "{7BF8F596-F3F9-4930-A0E0-F83823FE8FDA}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ProductReviewAnalyzer.Contracts", "Contracts\ProductReviewAnalyzer.Contracts.csproj", "{A7AD74D8-D0BB-455F-BE3C-89E5B6CC193C}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{48A9C13D-2D4A-4349-B750-1662AB087FBE}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{48A9C13D-2D4A-4349-B750-1662AB087FBE}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{48A9C13D-2D4A-4349-B750-1662AB087FBE}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{48A9C13D-2D4A-4349-B750-1662AB087FBE}.Release|Any CPU.Build.0 = Release|Any CPU
		{168785DF-BBAC-4360-99CB-A33F937B9504}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{168785DF-BBAC-4360-99CB-A33F937B9504}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{168785DF-BBAC-4360-99CB-A33F937B9504}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{168785DF-BBAC-4360-99CB-A33F937B9504}.Release|Any CPU.Build.0 = Release|Any CPU
		{86A8D6A6-0AD3-4BEA-BDA4-5EA007EE1012}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{86A8D6A6-0AD3-4BEA-BDA4-5EA007EE1012}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{86A8D6A6-0AD3-4BEA-BDA4-5EA007EE1012}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{86A8D6A6-0AD3-4BEA-BDA4-5EA007EE1012}.Release|Any CPU.Build.0 = Release|Any CPU
		{102C1C5F-051E-440F-B5E4-B3DAF006E512}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{102C1C5F-051E-440F-B5E4-B3DAF006E512}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{102C1C5F-051E-440F-B5E4-B3DAF006E512}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{102C1C5F-051E-440F-B5E4-B3DAF006E512}.Release|Any CPU.Build.0 = Release|Any CPU
		{0CE36696-2DD7-45AA-9D24-F129EA7C099A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{0CE36696-2DD7-45AA-9D24-F129EA7C099A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{0CE36696-2DD7-45AA-9D24-F129EA7C099A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{0CE36696-2DD7-45AA-9D24-F129EA7C099A}.Release|Any CPU.Build.0 = Release|Any CPU
		{09F51B30-1FA6-4A4A-87D4-D8459C0234B3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{09F51B30-1FA6-4A4A-87D4-D8459C0234B3}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{09F51B30-1FA6-4A4A-87D4-D8459C0234B3}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{09F51B30-1FA6-4A4A-87D4-D8459C0234B3}.Release|Any CPU.Build.0 = Release|Any CPU
		{22377247-BFE8-4088-95F0-B6B56BD398BC}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{22377247-BFE8-4088-95F0-B6B56BD398BC}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{22377247-BFE8-4088-95F0-B6B56BD398BC}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{22377247-BFE8-4088-95F0-B6B56BD398BC}.Release|Any CPU.Build.0 = Release|Any CPU
		{C68A55FA-E958-40E0-A367-3BD61A96701D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{C68A55FA-E958-40E0-A367-3BD61A96701D}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{C68A55FA-E958-40E0-A367-3BD61A96701D}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{C68A55FA-E958-40E0-A367-3BD61A96701D}.Release|Any CPU.Build.0 = Release|Any CPU
		{2CE2539E-1D00-428B-971D-9300D53F7AD4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{2CE2539E-1D00-428B-971D-9300D53F7AD4}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{2CE2539E-1D00-428B-971D-9300D53F7AD4}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{2CE2539E-1D00-428B-971D-9300D53F7AD4}.Release|Any CPU.Build.0 = Release|Any CPU
		{29FF9811-6470-4EF5-97CA-0BA10A9A0910}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{29FF9811-6470-4EF5-97CA-0BA10A9A0910}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{29FF9811-6470-4EF5-97CA-0BA10A9A0910}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{29FF9811-6470-4EF5-97CA-0BA10A9A0910}.Release|Any CPU.Build.0 = Release|Any CPU
		{B6F4E582-172C-4779-BBFC-055CD2B75F8A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{B6F4E582-172C-4779-BBFC-055CD2B75F8A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{B6F4E582-172C-4779-BBFC-055CD2B75F8A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{B6F4E582-172C-4779-BBFC-055CD2B75F8A}.Release|Any CPU.Build.0 = Release|Any CPU
		{ACB252FB-D817-412E-B782-B9858C2DEC1B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{ACB252FB-D817-412E-B782-B9858C2DEC1B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{ACB252FB-D817-412E-B782-B9858C2DEC1B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{ACB252FB-D817-412E-B782-B9858C2DEC1B}.Release|Any CPU.Build.0 = Release|Any CPU
		{EEE074DB-1F1F-4372-B9E0-733698E04DA3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{EEE074DB-1F1F-4372-B9E0-733698E04DA3}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{EEE074DB-1F1F-4372-B9E0-733698E04DA3}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{EEE074DB-1F1F-4372-B9E0-733698E04DA3}.Release|Any CPU.Build.0 = Release|Any CPU
		{E2ED5FB8-B7B2-4446-9B3F-65B0305E765A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{E2ED5FB8-B7B2-4446-9B3F-65B0305E765A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{E2ED5FB8-B7B2-4446-9B3F-65B0305E765A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{E2ED5FB8-B7B2-4446-9B3F-65B0305E765A}.Release|Any CPU.Build.0 = Release|Any CPU
		{58F70C4C-0039-4904-90F7-5AA25A41569F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{58F70C4C-0039-4904-90F7-5AA25A41569F}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{58F70C4C-0039-4904-90F7-5AA25A41569F}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{58F70C4C-0039-4904-90F7-5AA25A41569F}.Release|Any CPU.Build.0 = Release|Any CPU
		{741FDA23-53C5-49F4-84BF-65380BD2A491}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{741FDA23-53C5-49F4-84BF-65380BD2A491}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{741FDA23-53C5-49F4-84BF-65380BD2A491}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{741FDA23-53C5-49F4-84BF-65380BD2A491}.Release|Any CPU.Build.0 = Release|Any CPU
		{ECF84838-DB89-4B67-BEBD-2F9E47BCB399}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{ECF84838-DB89-4B67-BEBD-2F9E47BCB399}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{ECF84838-DB89-4B67-BEBD-2F9E47BCB399}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{ECF84838-DB89-4B67-BEBD-2F9E47BCB399}.Release|Any CPU.Build.0 = Release|Any CPU
		{487E19A7-A050-4129-BFA3-47F7045AE616}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{487E19A7-A050-4129-BFA3-47F7045AE616}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{487E19A7-A050-4129-BFA3-47F7045AE616}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{487E19A7-A050-4129-BFA3-47F7045AE616}.Release|Any CPU.Build.0 = Release|Any CPU
		{7BF8F596-F3F9-4930-A0E0-F83823FE8FDA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{7BF8F596-F3F9-4930-A0E0-F83823FE8FDA}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{7BF8F596-F3F9-4930-A0E0-F83823FE8FDA}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{7BF8F596-F3F9-4930-A0E0-F83823FE8FDA}.Release|Any CPU.Build.0 = Release|Any CPU
		{A7AD74D8-D0BB-455F-BE3C-89E5B6CC193C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A7AD74D8-D0BB-455F-BE3C-89E5B6CC193C}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A7AD74D8-D0BB-455F-BE3C-89E5B6CC193C}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A7AD74D8-D0BB-455F-BE3C-89E5B6CC193C}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{09F51B30-1FA6-4A4A-87D4-D8459C0234B3} = {2908EBB8-E348-4E02-B2EF-D874BFAFE975}
		{22377247-BFE8-4088-95F0-B6B56BD398BC} = {2908EBB8-E348-4E02-B2EF-D874BFAFE975}
		{C68A55FA-E958-40E0-A367-3BD61A96701D} = {2908EBB8-E348-4E02-B2EF-D874BFAFE975}
		{2CE2539E-1D00-428B-971D-9300D53F7AD4} = {2908EBB8-E348-4E02-B2EF-D874BFAFE975}
		{29FF9811-6470-4EF5-97CA-0BA10A9A0910} = {2908EBB8-E348-4E02-B2EF-D874BFAFE975}
		{B6F4E582-172C-4779-BBFC-055CD2B75F8A} = {B09774E6-B229-4BA2-BB96-B3F5E86FDAA8}
		{ACB252FB-D817-412E-B782-B9858C2DEC1B} = {B09774E6-B229-4BA2-BB96-B3F5E86FDAA8}
		{EEE074DB-1F1F-4372-B9E0-733698E04DA3} = {B09774E6-B229-4BA2-BB96-B3F5E86FDAA8}
		{E2ED5FB8-B7B2-4446-9B3F-65B0305E765A} = {B09774E6-B229-4BA2-BB96-B3F5E86FDAA8}
		{58F70C4C-0039-4904-90F7-5AA25A41569F} = {17CF8952-EE54-4C9F-81D3-2D59A67383C0}
		{741FDA23-53C5-49F4-84BF-65380BD2A491} = {17CF8952-EE54-4C9F-81D3-2D59A67383C0}
		{7BF8F596-F3F9-4930-A0E0-F83823FE8FDA} = {17CF8952-EE54-4C9F-81D3-2D59A67383C0}
	EndGlobalSection
EndGlobal

=== .github\workflows\build.yml ===

name: Build

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Set up .NET 9 SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.0.x

      - name: Restore
        run: dotnet restore ProductReviewAnalyzer.sln

      - name: Build
        run: dotnet build ProductReviewAnalyzer.sln --configuration Release --no-restore

      - name: Test
        run: dotnet test ProductReviewAnalyzer.sln --no-build --verbosity normal

=== .github\workflows\deploy.yml ===

name: Deploy to Docker Hub

on:
  workflow_run:
    workflows: [ "Build" ]
    types:
      - completed

jobs:
  deploy:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build & Push
        uses: docker/build-push-action@v5
        with:
          context: .
          file: build/Dockerfile
          push: true
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/product-review-analyzer:latest

=== AnalysisService\AnalysisService.API\appsettings.Development.json ===

{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}

=== AnalysisService\AnalysisService.API\appsettings.json ===

{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning"
    }
  },
  "OpenAI": {
    "ApiKey": null,
    "Model": "gpt-4o-mini"
  },
  "ConnectionStrings": {
    "RabbitMQ": null,
    "Postgres": null
  }
}

=== AnalysisService\AnalysisService.API\Dockerfile ===

FROM mcr.microsoft.com/dotnet/aspnet:9.0 AS base
USER $APP_UID
WORKDIR /app


FROM mcr.microsoft.com/dotnet/sdk:9.0 AS build
ARG BUILD_CONFIGURATION=Release
WORKDIR /src
COPY ["AnalysisService/AnalysisService.API/ProductReviewAnalyzer.AnalysisService.API.csproj", "AnalysisService/AnalysisService.API/"]
COPY ["AnalysisService/AnalysisService.Application/ProductReviewAnalyzer.AnalysisService.Application.csproj", "AnalysisService/AnalysisService.Application/"]
COPY ["AnalysisService/AnalysisService.Domain/ProductReviewAnalyzer.AnalysisService.Domain.csproj", "AnalysisService/AnalysisService.Domain/"]
COPY ["AnalysisService/AnalysisService.Infrastructure/ProductReviewAnalyzer.AnalysisService.Infrastructure.csproj", "AnalysisService/AnalysisService.Infrastructure/"]
COPY ["AnalysisService/AnalysisService.Messaging/ProductReviewAnalyzer.AnalysisService.Messaging.csproj", "AnalysisService/AnalysisService.Messaging/"]
COPY ["Contracts/ProductReviewAnalyzer.Contracts.csproj", "Contracts/"]
RUN dotnet restore "./AnalysisService/AnalysisService.API/ProductReviewAnalyzer.AnalysisService.API.csproj"
COPY . .
WORKDIR "/src/AnalysisService/AnalysisService.API"
RUN dotnet build "./ProductReviewAnalyzer.AnalysisService.API.csproj" -c $BUILD_CONFIGURATION -o /app/build

FROM build AS publish
ARG BUILD_CONFIGURATION=Release
RUN dotnet publish "./ProductReviewAnalyzer.AnalysisService.API.csproj" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "ProductReviewAnalyzer.AnalysisService.API.dll"]

=== AnalysisService\AnalysisService.API\ProductReviewAnalyzer.AnalysisService.API.csproj ===

<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <UserSecretsId>a37fdb68-7362-41f6-a574-d9b57b5fd680</UserSecretsId>
    <DockerDefaultTargetOS>Linux</DockerDefaultTargetOS>
    <DockerfileContext>..\..</DockerfileContext>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="AspNetCore.HealthChecks.NpgSql" Version="9.0.0" />
    <PackageReference Include="AspNetCore.HealthChecks.Rabbitmq" Version="9.0.0" />
    <PackageReference Include="FluentValidation.DependencyInjectionExtensions" Version="12.0.0" />
    <PackageReference Include="MediatR" Version="12.5.0" />
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="9.0.0" />
    <PackageReference Include="Microsoft.VisualStudio.Azure.Containers.Tools.Targets" Version="1.21.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\AnalysisService.Application\ProductReviewAnalyzer.AnalysisService.Application.csproj" />
    <ProjectReference Include="..\AnalysisService.Infrastructure\ProductReviewAnalyzer.AnalysisService.Infrastructure.csproj" />
    <ProjectReference Include="..\AnalysisService.Messaging\ProductReviewAnalyzer.AnalysisService.Messaging.csproj" />
  </ItemGroup>

</Project>

=== AnalysisService\AnalysisService.API\ProductReviewAnalyzer.AnalysisService.API.csproj.user ===

<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ActiveDebugProfile>Container (Dockerfile)</ActiveDebugProfile>
  </PropertyGroup>
</Project>

=== AnalysisService\AnalysisService.API\Program.cs ===

using ProductReviewAnalyzer.AnalysisService.Application;
using ProductReviewAnalyzer.AnalysisService.Infrastructure;
using ProductReviewAnalyzer.AnalysisService.Messaging;
using RabbitMQ.Client;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddApplication()
    .AddInfrastructure(builder.Configuration)
    .AddMessaging(builder.Configuration);

builder.Services.AddHealthChecks()
    .AddNpgSql(builder.Configuration.GetConnectionString("Postgres")!, name: "postgres")
    .AddRabbitMQ(sp =>
    {
        var cfg = sp.GetRequiredService<IConfiguration>();
        var rabbitUri = cfg.GetConnectionString("RabbitMQ")!;
        var factory = new ConnectionFactory
        {
            Uri = new Uri(rabbitUri)
        };
        return factory.CreateConnectionAsync();
    }, name: "rabbitmq");

var app = builder.Build();

app.MapHealthChecks("/health");

app.Run();

=== AnalysisService\AnalysisService.API\Properties\launchSettings.json ===

{
  "profiles": {
    "http": {
      "commandName": "Project",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "dotnetRunMessages": true,
      "applicationUrl": "http://localhost:5036"
    },
    "https": {
      "commandName": "Project",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "dotnetRunMessages": true,
      "applicationUrl": "https://localhost:7246;http://localhost:5036"
    },
    "Container (Dockerfile)": {
      "commandName": "Docker",
      "launchUrl": "{Scheme}://{ServiceHost}:{ServicePort}",
      "environmentVariables": {
        "ASPNETCORE_HTTPS_PORTS": "8081",
        "ASPNETCORE_HTTP_PORTS": "8080"
      },
      "publishAllPorts": true,
      "useSSL": true
    }
  },
  "$schema": "https://json.schemastore.org/launchsettings.json"
}

=== AnalysisService\AnalysisService.Application\DependencyInjection.cs ===

using FluentValidation;
using MediatR;
using Microsoft.Extensions.DependencyInjection;
using ProductReviewAnalyzer.AnalysisService.Application.Behaviors;

namespace ProductReviewAnalyzer.AnalysisService.Application;

public static class DependencyInjection
{
    public static IServiceCollection AddApplication(this IServiceCollection services)
    {
        services.AddMediatR(cfg =>
        {
            cfg.RegisterServicesFromAssembly(typeof(DependencyInjection).Assembly);
            cfg.AddOpenBehavior(typeof(RetryBehavior<,>));
        });

        services.AddValidatorsFromAssembly(typeof(DependencyInjection).Assembly);

        return services;
    }
}

=== AnalysisService\AnalysisService.Application\ProductReviewAnalyzer.AnalysisService.Application.csproj ===

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="FluentValidation" Version="12.0.0" />
    <PackageReference Include="FluentValidation.DependencyInjectionExtensions" Version="12.0.0" />
    <PackageReference Include="MediatR" Version="12.5.0" />
    <PackageReference Include="Polly" Version="8.5.2" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\AnalysisService.Domain\ProductReviewAnalyzer.AnalysisService.Domain.csproj" />
  </ItemGroup>

</Project>

=== AnalysisService\AnalysisService.Application\Behaviors\RetryBehavior.cs ===

using MediatR;
using Polly;
using Polly.Retry;

namespace ProductReviewAnalyzer.AnalysisService.Application.Behaviors;

public class RetryBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
    where TRequest : notnull
{
    private readonly AsyncRetryPolicy _policy =
        Policy
            .Handle<Exception>()
            .WaitAndRetryAsync(3, attempt => TimeSpan.FromSeconds(Math.Pow(2, attempt)));

    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken ct)
    {
        return await _policy.ExecuteAsync(_ => next(), ct);
    }
}

=== AnalysisService\AnalysisService.Application\Commands\AnalyzeReviewCommand.cs ===

using MediatR;
namespace ProductReviewAnalyzer.AnalysisService.Application.Commands;

/// <summary>
///  ÓÏ‡Ì‰‡ Á‡ÔÛÒÍ‡∫ LLM-‡Ì‡Î≥Á ÍÓÌÍÂÚÌÓ„Ó ‚≥‰„ÛÍÛ
/// </summary>
public sealed record AnalyzeReviewCommand(
    long ReviewId,
    long ProductId,
    string UserTitle,
    int? Mark,
    string Text,
    string? Dignity,
    string? Shortcomings,
    bool FromBuyer,
    DateTime CreatedAt) : IRequest<Guid>;

=== AnalysisService\AnalysisService.Application\Commands\AnalyzeReviewCommandHandler.cs ===

using MediatR;
using ProductReviewAnalyzer.AnalysisService.Application.Interfaces;
using ProductReviewAnalyzer.AnalysisService.Domain.Entities;

namespace ProductReviewAnalyzer.AnalysisService.Application.Commands;

public sealed class AnalyzeReviewCommandHandler : IRequestHandler<AnalyzeReviewCommand, Guid>
{
    private readonly IOpenAIService _openAi;
    private readonly IReviewAnalysisRepository _repo;

    public AnalyzeReviewCommandHandler(IOpenAIService openAi, IReviewAnalysisRepository repo)
    {
        _openAi = openAi;
        _repo = repo;
    }

    public async Task<Guid> Handle(AnalyzeReviewCommand c, CancellationToken ct)
    {
        var (prodSent,
            storeSent,
            prodPros,
            prodCons,
            prodCats,
            prodUsage,
            storePros,
            storeCons) = await _openAi.AnalyzeAsync(c.Text, ct);

        var doc = new ReviewAnalysis
        {
            ReviewId = c.ReviewId,
            ProductId = c.ProductId,
            UserTitle = c.UserTitle,
            Mark = c.Mark,
            Dignity = c.Dignity,
            Shortcomings = c.Shortcomings,
            FromBuyer = c.FromBuyer,
            ReviewCreatedAt = c.CreatedAt,
            RawText = c.Text,

            ProductSentiment = prodSent,
            StoreSentiment = storeSent,
            ProductPros = prodPros,
            ProductCons = prodCons,
            ProductCategories = prodCats,
            ProductUsageInsights = prodUsage,
            StorePros = storePros,
            StoreCons = storeCons
        };

        await _repo.InsertAsync(doc, ct);
        return doc.Id;
    }
}

=== AnalysisService\AnalysisService.Application\Commands\AnalyzeReviewCommandValidator.cs ===

using FluentValidation;

namespace ProductReviewAnalyzer.AnalysisService.Application.Commands;

public class AnalyzeReviewCommandValidator : AbstractValidator<AnalyzeReviewCommand>
{
    public AnalyzeReviewCommandValidator()
    {
        RuleFor(c => c.ReviewId).GreaterThan(0);
        RuleFor(c => c.ProductId).GreaterThan(0);
        RuleFor(c => c.UserTitle).NotEmpty();
        RuleFor(c => c.Text).NotEmpty().MaximumLength(20_000);
    }
}

=== AnalysisService\AnalysisService.Application\Interfaces\IOpenAIService.cs ===

using ProductReviewAnalyzer.AnalysisService.Domain.ValueObjects;

namespace ProductReviewAnalyzer.AnalysisService.Application.Interfaces;

/// <summary>
/// ¿·ÒÚ‡Íˆ≥ˇ Ì‡‰ ‚ËÍÎËÍÓÏ ChatGPT / Assistants API
/// </summary>
public interface IOpenAIService
{
    Task<(Sentiment prodSent,
            Sentiment storeSent,
            IReadOnlyList<string> prodPros,
            IReadOnlyList<string> prodCons,
            IReadOnlyList<string> prodCategories,
            IReadOnlyList<string> prodUsage,
            IReadOnlyList<string> storePros,
            IReadOnlyList<string> storeCons)>
        AnalyzeAsync(string reviewText, CancellationToken ct);
}

=== AnalysisService\AnalysisService.Application\Interfaces\IReviewAnalysisRepository.cs ===

using ProductReviewAnalyzer.AnalysisService.Domain.Entities;

namespace ProductReviewAnalyzer.AnalysisService.Application.Interfaces;

public interface IReviewAnalysisRepository
{
    Task InsertAsync(ReviewAnalysis entity, CancellationToken ct);
}

=== AnalysisService\AnalysisService.Domain\ProductReviewAnalyzer.AnalysisService.Domain.csproj ===

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="FluentValidation.DependencyInjectionExtensions" Version="12.0.0" />
    <PackageReference Include="MediatR" Version="12.5.0" />
  </ItemGroup>

</Project>

=== AnalysisService\AnalysisService.Domain\Entities\ReviewAnalysis.cs ===

using ProductReviewAnalyzer.AnalysisService.Domain.ValueObjects;

namespace ProductReviewAnalyzer.AnalysisService.Domain.Entities;

public class ReviewAnalysis
{
    // ÔÂ‚ËÌÌËÈ ÍÎ˛˜ ‰ÓÍÛÏÂÌÚ‡ Marten
    public Guid Id { get; init; } = Guid.NewGuid();

    // ‰‡Ì≥ Ò‡ÏÓ„Ó ‚≥‰„ÛÍÛ
    public long ReviewId { get; init; }
    public long ProductId { get; init; }
    public string Store { get; init; } = default!;
    public string UserTitle { get; init; } = default!;
    public int? Mark { get; init; }
    public string? Dignity { get; init; }
    public string? Shortcomings { get; init; }
    public bool FromBuyer { get; init; }
    public DateTime ReviewCreatedAt { get; init; }
    public string RawText { get; init; } = default!;

    public Sentiment ProductSentiment { get; set; }
    public Sentiment StoreSentiment { get; set; }

    public IReadOnlyList<string> ProductPros { get; set; } = Array.Empty<string>();
    public IReadOnlyList<string> ProductCons { get; set; } = Array.Empty<string>();
    public IReadOnlyList<string> ProductCategories { get; set; } = Array.Empty<string>();
    public IReadOnlyList<string> ProductUsageInsights { get; set; } = Array.Empty<string>();

    public IReadOnlyList<string> StorePros { get; set; } = Array.Empty<string>();
    public IReadOnlyList<string> StoreCons { get; set; } = Array.Empty<string>();

    public DateTime AnalysisCreatedAtUtc { get; init; } = DateTime.UtcNow;
}

=== AnalysisService\AnalysisService.Domain\Events\ReviewAnalyzedDomainEvent.cs ===

using MediatR;
using ProductReviewAnalyzer.AnalysisService.Domain.Entities;

namespace ProductReviewAnalyzer.AnalysisService.Domain.Events;

public record ReviewAnalyzedDomainEvent(ReviewAnalysis Analysis) : INotification;

=== AnalysisService\AnalysisService.Domain\Properties\launchSettings.json ===

{
  "profiles": {
    "AnalysisService.Domain": {
      "commandName": "Project"
    },
    "Container (Dockerfile)": {
      "commandName": "Docker"
    }
  }
}

=== AnalysisService\AnalysisService.Domain\ValueObjects\Sentiment.cs ===

namespace ProductReviewAnalyzer.AnalysisService.Domain.ValueObjects;

public enum Sentiment
{
    Negative = -1,
    Neutral = 0,
    Positive = 1
}

=== AnalysisService\AnalysisService.Infrastructure\InfrastructureDependencyInjection.cs ===

using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using ProductReviewAnalyzer.AnalysisService.Application.Interfaces;
using ProductReviewAnalyzer.AnalysisService.Infrastructure.OpenAI;
using ProductReviewAnalyzer.AnalysisService.Infrastructure.Persistence;

namespace ProductReviewAnalyzer.AnalysisService.Infrastructure;

public static class InfrastructureDependencyInjection
{
    public static IServiceCollection AddInfrastructure(this IServiceCollection services, IConfiguration cfg)
    {
        services.AddMartenStore(cfg);

        services.AddHttpClient<IOpenAIService, OpenAIService>(client =>
        {
            client.BaseAddress = new Uri("https://api.openai.com");
            client.DefaultRequestHeaders.Authorization =
                new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", cfg["OpenAI:ApiKey"]);
        });

        services.AddScoped<IReviewAnalysisRepository, ReviewAnalysisRepository>();

        return services;
    }
}

=== AnalysisService\AnalysisService.Infrastructure\ProductReviewAnalyzer.AnalysisService.Infrastructure.csproj ===

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Marten" Version="7.40.4" />
    <PackageReference Include="Microsoft.Extensions.Http" Version="9.0.5" />
    <PackageReference Include="Weasel.Core" Version="7.14.2" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\AnalysisService.Application\ProductReviewAnalyzer.AnalysisService.Application.csproj" />
  </ItemGroup>

</Project>

=== AnalysisService\AnalysisService.Infrastructure\OpenAI\OpenAIService.cs ===

using System.Net.Http.Json;
using System.Text.Json;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using ProductReviewAnalyzer.AnalysisService.Application.Interfaces;
using ProductReviewAnalyzer.AnalysisService.Domain.ValueObjects;

namespace ProductReviewAnalyzer.AnalysisService.Infrastructure.OpenAI;

internal sealed class OpenAIService(HttpClient http, IConfiguration cfg, ILogger<OpenAIService> logger)
    : IOpenAIService
{
    private readonly ILogger<OpenAIService> _logger = logger;
    private readonly string _model = cfg["OpenAI:Model"] ?? "gpt-4o-mini";

    public async Task<(Sentiment prodSent,
                       Sentiment storeSent,
                       IReadOnlyList<string> prodPros,
                       IReadOnlyList<string> prodCons,
                       IReadOnlyList<string> prodCategories,
                       IReadOnlyList<string> prodUsage,
                       IReadOnlyList<string> storePros,
                       IReadOnlyList<string> storeCons)>
        AnalyzeAsync(string reviewText, CancellationToken ct)
    {
        var req = new
        {
            model = _model,
            temperature = 0.2,
            messages = new[]
            {
                new { role = "system", content =
@"You are an e-commerce review analysis assistant.
Return ONLY valid minified JSON with the following schema:
{
  ""product"": {
    ""sentiment"": ""positive|neutral|negative"",
    ""pros"": [""string""...],
    ""cons"": [""string""...],
    ""categories"": [""string""...],
    ""usage_insights"": [""string""...]        // everyday usage, nuances, tips
  },
  ""store"": {
    ""sentiment"": ""positive|neutral|negative"",
    ""pros"": [""string""...],
    ""cons"": [""string""...]
  }
}" },
                new { role = "user",   content = reviewText }
            }
        };

        var res = await http.PostAsJsonAsync("/v1/chat/completions", req, ct);
        res.EnsureSuccessStatusCode();

        var root = await res.Content.ReadFromJsonAsync<JsonDocument>(cancellationToken: ct);
        var jsonStr = root!.RootElement
                           .GetProperty("choices")[0]
                           .GetProperty("message")
                           .GetProperty("content").GetString()!;

        var parsed = JsonSerializer.Deserialize<JsonElement>(jsonStr);

        Sentiment Map(string s) => s switch
        {
            "positive" => Sentiment.Positive,
            "negative" => Sentiment.Negative,
            _ => Sentiment.Neutral
        };

        var prod = parsed.GetProperty("product");
        var store = parsed.GetProperty("store");

        IReadOnlyList<string> Arr(JsonElement e, string prop) =>
            e.GetProperty(prop).EnumerateArray().Select(x => x.GetString()!).ToList();

        return (
            Map(prod.GetProperty("sentiment").GetString()!),
            Map(store.GetProperty("sentiment").GetString()!),
            Arr(prod, "pros"),
            Arr(prod, "cons"),
            Arr(prod, "categories"),
            Arr(prod, "usage_insights"),
            Arr(store, "pros"),
            Arr(store, "cons"));
    }
}

=== AnalysisService\AnalysisService.Infrastructure\Persistence\MartenExtensions.cs ===

using Marten;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Weasel.Core;

namespace ProductReviewAnalyzer.AnalysisService.Infrastructure.Persistence;

public static class MartenExtensions
{
    public static IServiceCollection AddMartenStore(this IServiceCollection services, IConfiguration cfg)
    {
        var conn = cfg.GetConnectionString("Postgres")
                   ?? throw new InvalidOperationException("Postgres connection string not configured");

        services.AddMarten(opts =>
        {
            opts.Connection(conn);
            opts.AutoCreateSchemaObjects = AutoCreate.All;
        });

        return services;
    }
}

=== AnalysisService\AnalysisService.Infrastructure\Persistence\ReviewAnalysisRepository.cs ===

using Marten;
using ProductReviewAnalyzer.AnalysisService.Application.Interfaces;
using ProductReviewAnalyzer.AnalysisService.Domain.Entities;

namespace ProductReviewAnalyzer.AnalysisService.Infrastructure.Persistence;

internal sealed class ReviewAnalysisRepository : IReviewAnalysisRepository
{
    private readonly IDocumentSession _session;
    public ReviewAnalysisRepository(IDocumentSession session) => _session = session;

    public async Task InsertAsync(ReviewAnalysis entity, CancellationToken ct)
    {
        _session.Store(entity);
        await _session.SaveChangesAsync(ct);
    }
}

=== AnalysisService\AnalysisService.Messaging\MessagingDependencyInjection.cs ===

using MassTransit;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using ProductReviewAnalyzer.AnalysisService.Messaging.Consumers;

namespace ProductReviewAnalyzer.AnalysisService.Messaging;

public static class MessagingDependencyInjection
{
    public static IServiceCollection AddMessaging(this IServiceCollection services, IConfiguration cfg)
    {
        var rabbitConn = cfg.GetConnectionString("RabbitMQ")
                         ?? throw new InvalidOperationException("RabbitMQ connection string not configured");

        services.AddMassTransit(x =>
        {
            x.SetKebabCaseEndpointNameFormatter();
            x.AddConsumer<NewReviewReceivedConsumer>();

            x.UsingRabbitMq((context, cfgRabbit) =>
            {
                cfgRabbit.Host(rabbitConn);

                cfgRabbit.ConfigureEndpoints(context);
            });
        });

        return services;
    }
}

=== AnalysisService\AnalysisService.Messaging\ProductReviewAnalyzer.AnalysisService.Messaging.csproj ===

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="MassTransit" Version="8.4.1" />
    <PackageReference Include="MassTransit.RabbitMQ" Version="8.4.1" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\Contracts\ProductReviewAnalyzer.Contracts.csproj" />
    <ProjectReference Include="..\AnalysisService.Application\ProductReviewAnalyzer.AnalysisService.Application.csproj" />
  </ItemGroup>

</Project>

=== AnalysisService\AnalysisService.Messaging\Consumers\NewReviewReceivedConsumer.cs ===

using MassTransit;
using MediatR;
using Microsoft.Extensions.Logging;
using ProductReviewAnalyzer.AnalysisService.Application.Commands;
using ProductReviewAnalyzer.Contracts;

namespace ProductReviewAnalyzer.AnalysisService.Messaging.Consumers;

public sealed class NewReviewReceivedConsumer(IMediator mediator, ILogger<NewReviewReceivedConsumer> logger) : IConsumer<NewReviewReceived>
{
    private readonly IMediator _mediator = mediator;
    private readonly ILogger<NewReviewReceivedConsumer> _logger = logger;

    public async Task Consume(ConsumeContext<NewReviewReceived> ctx)
    {
        var m = ctx.Message;
        _logger.LogInformation("–ê–Ω–∞–ª—ñ–∑—É—î–º–æ ReviewId={ReviewId}", m.Id);

        await _mediator.Send(new AnalyzeReviewCommand(
            m.Id,
            m.ProductId,
            m.UserTitle,
            m.Mark,
            m.Text,
            m.Dignity,
            m.Shortcomings,
            m.FromBuyer,
            m.CreatedAt), ctx.CancellationToken);

        _logger.LogInformation("–ê–Ω–∞–ª—ñ–∑ –∑–∞–≤–µ—Ä—à–µ–Ω–æ ReviewId={ReviewId}", m.Id);
    }
}

=== ApiGateway\appsettings.Development.json ===

{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}

=== ApiGateway\appsettings.json ===

{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
    }
  },
  "Jwt": {
    "Issuer": null,
    "Audience": null,
    "Key": null
  },
  "RateLimiting": {
    "PermitLimit": 0,
    "WindowSeconds": 0
  }
}

=== ApiGateway\Dockerfile ===

FROM mcr.microsoft.com/dotnet/aspnet:9.0 AS base
USER $APP_UID
WORKDIR /app


FROM mcr.microsoft.com/dotnet/sdk:9.0 AS build
ARG BUILD_CONFIGURATION=Release
WORKDIR /src
COPY ["ApiGateway/ProductReviewAnalyzer.ApiGateway.csproj", "ApiGateway/"]
RUN dotnet restore "./ApiGateway/ProductReviewAnalyzer.ApiGateway.csproj"
COPY . .
WORKDIR "/src/ApiGateway"
RUN dotnet build "./ProductReviewAnalyzer.ApiGateway.csproj" -c $BUILD_CONFIGURATION -o /app/build

FROM build AS publish
ARG BUILD_CONFIGURATION=Release
RUN dotnet publish "./ProductReviewAnalyzer.ApiGateway.csproj" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "ProductReviewAnalyzer.ApiGateway.dll"]

=== ApiGateway\ProductReviewAnalyzer.ApiGateway.csproj ===

<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <UserSecretsId>c2200a6d-3508-40b3-bb29-ce99723a4763</UserSecretsId>
    <DockerDefaultTargetOS>Linux</DockerDefaultTargetOS>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="9.0.5" />
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="9.0.0" />
    <PackageReference Include="Microsoft.VisualStudio.Azure.Containers.Tools.Targets" Version="1.21.0" />
    <PackageReference Include="Yarp.ReverseProxy" Version="2.3.0" />
  </ItemGroup>

</Project>

=== ApiGateway\ProductReviewAnalyzer.ApiGateway.csproj.user ===

<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ActiveDebugProfile>Container (Dockerfile)</ActiveDebugProfile>
  </PropertyGroup>
</Project>

=== ApiGateway\Program.cs ===

using System.Text;
using System.Threading.RateLimiting;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.AspNetCore.RateLimiting;
using Microsoft.IdentityModel.Tokens;

var builder = WebApplication.CreateBuilder(args);

builder.Configuration
    .SetBasePath(builder.Environment.ContentRootPath)
    .AddJsonFile("appsettings.json", optional: false, reloadOnChange: true)
    .AddJsonFile("yarp.json", optional: false, reloadOnChange: true)
    .AddEnvironmentVariables();

var jwt = builder.Configuration.GetSection("Jwt");
var key = Encoding.UTF8.GetBytes(jwt["Key"]!);

builder.Services
    .AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(o =>
    {
        o.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuerSigningKey = true,
            IssuerSigningKey = new SymmetricSecurityKey(key),
            ValidateIssuer = true,
            ValidIssuer = jwt["Issuer"],
            ValidateAudience = true,
            ValidAudience = jwt["Audience"],
            ValidateLifetime = true
        };
    });

builder.Services.AddAuthorization(opts =>
    opts.AddPolicy("ApiPolicy", policy =>
        policy.RequireAuthenticatedUser()));


var rlCfg = builder.Configuration.GetSection("RateLimiting");
builder.Services.AddRateLimiter(options =>
{
    options.RejectionStatusCode = 429;
    options.AddFixedWindowLimiter("global", opt =>
    {
        opt.PermitLimit = rlCfg.GetValue<int>("PermitLimit", 60);
        opt.Window = TimeSpan.FromSeconds(rlCfg.GetValue<int>("WindowSeconds", 60));
        opt.QueueProcessingOrder = QueueProcessingOrder.OldestFirst;
        opt.QueueLimit = 0;
    });
});


builder.Services
    .AddReverseProxy()
    .LoadFromConfig(builder.Configuration.GetSection("ReverseProxy"));


var app = builder.Build();

app.UseRateLimiter();
app.UseAuthentication();
app.UseAuthorization();

app.MapReverseProxy();

app.Run();

=== ApiGateway\yarp.json ===

{
  "ReverseProxy": {
    "Routes": {
      "scraper-rozetka": {
        "ClusterId": "scraper-rozetka",
        "AuthorizationPolicy": "ApiPolicy",
        "Match": {
          "Path": "/api/scraper/rozetka/{**catch-all}"
        },
        "Transforms": [
          { "PathRemovePrefix": "/api/scraper/rozetka" }
        ]
      },
      "scraper-allo": {
        "ClusterId": "scraper-allo",
        "AuthorizationPolicy": "ApiPolicy",
        "Match": {
          "Path": "/api/scraper/allo/{**catch-all}"
        },
        "Transforms": [
          { "PathRemovePrefix": "/api/scraper/allo" }
        ]
      },
      "history": {
        "ClusterId": "history",
        "AuthorizationPolicy": "ApiPolicy",
        "Match": {
          "Path": "/api/history/{**catch-all}"
        },
        "Transforms": [
          { "PathRemovePrefix": "/api/history" }
        ]
      },
      "analysis": {
        "ClusterId": "analysis",
        "AuthorizationPolicy": "ApiPolicy",
        "Match": {
          "Path": "/api/analysis/{**catch-all}"
        },
        "Transforms": [
          { "PathRemovePrefix": "/api/analysis" }
        ]
      },
      "tableau": {
        "ClusterId": "tableau",
        "AuthorizationPolicy": "ApiPolicy",
        "Match": {
          "Path": "/api/tableau/{**catch-all}"
        },
        "Transforms": [
          { "PathRemovePrefix": "/api/tableau" }
        ]
      },
      "webapp": {
        "ClusterId": "webapp",
        "Match": {
          "Path": "/{**catch-all}"
        }
      }
    },
    "Clusters": {
      "scraper-rozetka": {
        "Destinations": {
          "d1": { "Address": "http://scraper-rozetka:8080/api/scraper/rozetka/" }
        }
      },
      "scraper-allo": {
        "Destinations": {
          "d1": { "Address": "http://scraper-allo:8080/" }
        }
      },
      "history": {
        "Destinations": {
          "d1": { "Address": "http://historyservice:8080/api/history/" }
        }
      },
      "analysis": {
        "Destinations": {
          "d1": { "Address": "http://analysisservice:8080/" }
        }
      },
      "tableau": {
        "Destinations": {
          "d1": { "Address": "http://tableauexporter:8080/" }
        }
      },
      "webapp": {
        "Destinations": {
          "d1": { "Address": "http://webapp:8080/" }
        }
      }
    }
  }
}

=== ApiGateway\Properties\launchSettings.json ===

{
  "profiles": {
    "http": {
      "commandName": "Project",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "dotnetRunMessages": true,
      "applicationUrl": "http://localhost:5117"
    },
    "https": {
      "commandName": "Project",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "dotnetRunMessages": true,
      "applicationUrl": "https://localhost:7059;http://localhost:5117"
    },
    "Container (Dockerfile)": {
      "commandName": "Docker",
      "launchUrl": "{Scheme}://{ServiceHost}:{ServicePort}",
      "environmentVariables": {
        "ASPNETCORE_HTTPS_PORTS": "8081",
        "ASPNETCORE_HTTP_PORTS": "8080"
      },
      "publishAllPorts": true,
      "useSSL": true
    }
  },
  "$schema": "https://json.schemastore.org/launchsettings.json"
}

=== Common\ProductReviewAnalyzer.Common.csproj ===

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="9.0.5" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="9.0.5">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.EntityFrameworkCore.Relational" Version="9.0.5" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Binder" Version="9.0.5" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="9.0.5" />
    <PackageReference Include="Microsoft.Extensions.Options.ConfigurationExtensions" Version="9.0.5" />
    <PackageReference Include="Swashbuckle.AspNetCore" Version="8.1.2" />
  </ItemGroup>
</Project>

=== Common\Configuration\OpenAIOptions.cs ===

namespace ProductReviewAnalyzer.Common.Configuration;

public sealed record OpenAIOptions
{
    public const string SectionName = "OpenAI";
    public required string ApiKey { get; init; }
    public string? Organization { get; init; }
}

=== Common\Extensions\DependencyInjection.cs ===

using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Configuration;
using ProductReviewAnalyzer.Common.Configuration;

namespace ProductReviewAnalyzer.Common.Extensions;

public static class DependencyInjection
{
    public static IServiceCollection AddCommon(this IServiceCollection services, IConfiguration config)
    {
        services.Configure<OpenAIOptions>(config.GetSection(OpenAIOptions.SectionName));
        return services;
    }
}

=== Common\Persistence\DatabaseMigrator.cs ===

using Microsoft.EntityFrameworkCore;

namespace ProductReviewAnalyzer.Common.Persistence;

public class DatabaseMigrator<TContext>(TContext db) : IDatabaseMigrator
    where TContext : DbContext
{
    public Task MigrateAsync(CancellationToken cancellationToken = default)
        => db.Database.MigrateAsync(cancellationToken);
}

=== Common\Persistence\IDatabaseMigrator.cs ===

namespace ProductReviewAnalyzer.Common.Persistence;

public interface IDatabaseMigrator
{
    Task MigrateAsync(CancellationToken cancellationToken = default);
}

=== Common\Persistence\ServiceCollectionExtensions.cs ===

using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;

namespace ProductReviewAnalyzer.Common.Persistence
{
    public static class ServiceCollectionExtensions
    {
        public static IServiceCollection AddDbContextWithMigrator<TContext>(
            this IServiceCollection services,
            Action<DbContextOptionsBuilder> configureDb)
            where TContext : DbContext
        {
            services.AddDbContext<TContext>(configureDb);
            services.AddScoped<IDatabaseMigrator, DatabaseMigrator<TContext>>();
            return services;
        }
    }
}

=== Contracts\AnalysisCompleted.cs ===

namespace ProductReviewAnalyzer.Contracts;

public record AnalysisCompleted(
    Guid AnalysisId,
    long ReviewId,
    string GoodsId,
    string Store,
    decimal ProductSentiment,
    decimal StoreSentiment,
    IReadOnlyList<string> ProductPros,
    IReadOnlyList<string> ProductCons,
    IReadOnlyList<string> ProductCategories,
    IReadOnlyList<string> ProductUsageInsights,
    IReadOnlyList<string> StorePros,
    IReadOnlyList<string> StoreCons,
    DateTime AnalyzedAtUtc);

=== Contracts\NewReviewReceived.cs ===

namespace ProductReviewAnalyzer.Contracts;

public record NewReviewReceived(
    long Id,
    long ProductId,
    string UserTitle,
    int? Mark,
    string Text,
    string? Dignity,
    string? Shortcomings,
    bool FromBuyer,
    DateTime CreatedAt);

=== Contracts\ProductReviewAnalyzer.Contracts.csproj ===

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>

=== HistoryService\HistoryService.API\appsettings.Development.json ===

{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}

=== HistoryService\HistoryService.API\appsettings.json ===

{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning"
    }
  },
  "ConnectionStrings": {
    "SqlServer": null
  }
}

=== HistoryService\HistoryService.API\Dockerfile ===

FROM mcr.microsoft.com/dotnet/aspnet:9.0 AS base
USER $APP_UID
WORKDIR /app


FROM mcr.microsoft.com/dotnet/sdk:9.0 AS build
ARG BUILD_CONFIGURATION=Release
WORKDIR /src
COPY ["HistoryService/HistoryService.API/ProductReviewAnalyzer.HistoryService.API.csproj", "HistoryService/HistoryService.API/"]
COPY ["HistoryService/HistoryService.Application/ProductReviewAnalyzer.HistoryService.Application.csproj", "HistoryService/HistoryService.Application/"]
COPY ["HistoryService/HistoryService.Domain/ProductReviewAnalyzer.HistoryService.Domain.csproj", "HistoryService/HistoryService.Domain/"]
COPY ["HistoryService/HistoryService.Infrastructure/ProductReviewAnalyzer.HistoryService.Infrastructure.csproj", "HistoryService/HistoryService.Infrastructure/"]
COPY ["Common/ProductReviewAnalyzer.Common.csproj", "Common/"]
RUN dotnet restore "./HistoryService/HistoryService.API/ProductReviewAnalyzer.HistoryService.API.csproj"
COPY . .
WORKDIR "/src/HistoryService/HistoryService.API"
RUN dotnet build "./ProductReviewAnalyzer.HistoryService.API.csproj" -c $BUILD_CONFIGURATION -o /app/build

FROM build AS publish
ARG BUILD_CONFIGURATION=Release
RUN dotnet publish "./ProductReviewAnalyzer.HistoryService.API.csproj" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "ProductReviewAnalyzer.HistoryService.API.dll"]

=== HistoryService\HistoryService.API\ProductReviewAnalyzer.HistoryService.API.csproj ===

<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <UserSecretsId>c1a46866-7efe-43ec-bcab-e434175d3c06</UserSecretsId>
    <DockerDefaultTargetOS>Linux</DockerDefaultTargetOS>
    <DockerfileContext>..\..</DockerfileContext>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="9.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="9.0.5">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.VisualStudio.Azure.Containers.Tools.Targets" Version="1.21.0" />
    <PackageReference Include="Swashbuckle.AspNetCore" Version="8.1.2" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\HistoryService.Application\ProductReviewAnalyzer.HistoryService.Application.csproj" />
    <ProjectReference Include="..\HistoryService.Infrastructure\ProductReviewAnalyzer.HistoryService.Infrastructure.csproj" />
  </ItemGroup>

</Project>

=== HistoryService\HistoryService.API\ProductReviewAnalyzer.HistoryService.API.csproj.user ===

<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ActiveDebugProfile>Container (Dockerfile)</ActiveDebugProfile>
  </PropertyGroup>
</Project>

=== HistoryService\HistoryService.API\Program.cs ===

using MediatR;
using Microsoft.EntityFrameworkCore;
using ProductReviewAnalyzer.Common.Persistence;
using ProductReviewAnalyzer.HistoryService.Application;
using ProductReviewAnalyzer.HistoryService.Application.Commands.CreateHistoryRecord;
using ProductReviewAnalyzer.HistoryService.Application.Queries.GetHistoryRecords;
using ProductReviewAnalyzer.HistoryService.Domain.ValueObjects;
using ProductReviewAnalyzer.HistoryService.Infrastructure;
using ProductReviewAnalyzer.HistoryService.Infrastructure.Persistence;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddApplication()
    .AddInfrastructure(builder.Configuration)
    .AddEndpointsApiExplorer()
    .AddSwaggerGen();

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

using (var scope = app.Services.CreateScope())
{
    var migrators = scope.ServiceProvider.GetServices<IDatabaseMigrator>();
    foreach (var migrator in migrators)
    {
        await migrator.MigrateAsync();
    }
}

app.MapGet("/api/history",
    async (IMediator mediator, CancellationToken ct)
        => Results.Ok(await mediator.Send(new GetHistoryRecordsQuery(), ct)));

app.MapPost("/api/history",
    async (CreateHistoryRecordRequest req, IMediator mediator, CancellationToken ct) =>
    {
        var id = await mediator.Send(new CreateHistoryRecordCommand(req.Url, req.Status), ct);
        return Results.Created($"/api/history/{id}", new { id });
    });

app.Run();

record CreateHistoryRecordRequest(string Url, RequestStatus Status);

=== HistoryService\HistoryService.API\Properties\launchSettings.json ===

{
  "profiles": {
    "http": {
      "commandName": "Project",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "dotnetRunMessages": true,
      "applicationUrl": "http://localhost:5206"
    },
    "https": {
      "commandName": "Project",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "dotnetRunMessages": true,
      "applicationUrl": "https://localhost:7230;http://localhost:5206"
    },
    "Container (Dockerfile)": {
      "commandName": "Docker",
      "launchUrl": "{Scheme}://{ServiceHost}:{ServicePort}",
      "environmentVariables": {
        "ASPNETCORE_HTTPS_PORTS": "8081",
        "ASPNETCORE_HTTP_PORTS": "8080"
      },
      "publishAllPorts": true,
      "useSSL": true
    }
  },
  "$schema": "https://json.schemastore.org/launchsettings.json"
}

=== HistoryService\HistoryService.Application\DependencyInjection.cs ===

using FluentValidation;
using MediatR;
using Microsoft.Extensions.DependencyInjection;
using ProductReviewAnalyzer.HistoryService.Application.Behaviors;

namespace ProductReviewAnalyzer.HistoryService.Application;

public static class DependencyInjection
{
    public static IServiceCollection AddApplication(this IServiceCollection services)
    {
        services.AddMediatR(cfg =>
        {
            cfg.RegisterServicesFromAssembly(typeof(DependencyInjection).Assembly);
            cfg.AddOpenBehavior(typeof(UnitOfWorkBehavior<,>));
        });

        services.AddValidatorsFromAssembly(typeof(DependencyInjection).Assembly);

        return services;
    }
}

=== HistoryService\HistoryService.Application\ProductReviewAnalyzer.HistoryService.Application.csproj ===

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="FluentValidation" Version="12.0.0" />
    <PackageReference Include="FluentValidation.DependencyInjectionExtensions" Version="12.0.0" />
    <PackageReference Include="MediatR" Version="12.5.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\HistoryService.Domain\ProductReviewAnalyzer.HistoryService.Domain.csproj" />
  </ItemGroup>

</Project>

=== HistoryService\HistoryService.Application\Behaviors\UnitOfWorkBehavior.cs ===

using MediatR;
using ProductReviewAnalyzer.HistoryService.Application.Interfaces;

namespace ProductReviewAnalyzer.HistoryService.Application.Behaviors;

public class UnitOfWorkBehavior<TRequest, TResponse>(IUnitOfWork uow) : IPipelineBehavior<TRequest, TResponse>
    where TRequest : notnull
{
    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken ct)
    {
        var response = await next(ct);
        await uow.SaveChangesAsync(ct);
        return response;
    }
}

=== HistoryService\HistoryService.Application\Commands\CreateHistoryRecord\CreateHistoryRecordCommand.cs ===

using MediatR;
using ProductReviewAnalyzer.HistoryService.Domain.ValueObjects;

namespace ProductReviewAnalyzer.HistoryService.Application.Commands.CreateHistoryRecord;

public record CreateHistoryRecordCommand(string Url, RequestStatus Status) : IRequest<Guid>;

=== HistoryService\HistoryService.Application\Commands\CreateHistoryRecord\CreateHistoryRecordCommandHandler.cs ===

using MediatR;
using ProductReviewAnalyzer.HistoryService.Application.Interfaces;
using ProductReviewAnalyzer.HistoryService.Domain.Entities;

namespace ProductReviewAnalyzer.HistoryService.Application.Commands.CreateHistoryRecord;

public class CreateHistoryRecordCommandHandler(IHistoryRepository repo, IUnitOfWork uow)
    : IRequestHandler<CreateHistoryRecordCommand, Guid>
{
    public async Task<Guid> Handle(CreateHistoryRecordCommand cmd, CancellationToken ct)
    {
        var entity = new HistoryRecord
        {
            Url = cmd.Url,
            RequestedAtUtc = DateTime.UtcNow,
            Status = cmd.Status
        };

        await repo.AddAsync(entity, ct);
        await uow.SaveChangesAsync(ct);

        return entity.Id;
    }
}

=== HistoryService\HistoryService.Application\Commands\CreateHistoryRecord\CreateHistoryRecordCommandValidator.cs ===

using FluentValidation;

namespace ProductReviewAnalyzer.HistoryService.Application.Commands.CreateHistoryRecord;

public class CreateHistoryRecordCommandValidator : AbstractValidator<CreateHistoryRecordCommand>
{
    public CreateHistoryRecordCommandValidator()
    {
        RuleFor(r => r.Url).NotEmpty().MaximumLength(2048).Must(u => Uri.IsWellFormedUriString(u, UriKind.Absolute));
        RuleFor(r => r.Status).IsInEnum();
    }
}

=== HistoryService\HistoryService.Application\DTOs\HistoryRecordDto.cs ===

using ProductReviewAnalyzer.HistoryService.Domain.ValueObjects;

namespace ProductReviewAnalyzer.HistoryService.Application.DTOs;

public record HistoryRecordDto(Guid Id, string Url, DateTime RequestedAtUtc, RequestStatus Status);

=== HistoryService\HistoryService.Application\Interfaces\IHistoryRepository.cs ===

using ProductReviewAnalyzer.HistoryService.Domain.Entities;
using System.Linq.Expressions;

namespace ProductReviewAnalyzer.HistoryService.Application.Interfaces;

public interface IHistoryRepository
{
    Task AddAsync(HistoryRecord entity, CancellationToken ct);
    Task<IReadOnlyList<HistoryRecord>> ListAsync(Expression<Func<HistoryRecord, bool>>? filter, CancellationToken ct);
}

=== HistoryService\HistoryService.Application\Interfaces\IUnitOfWork.cs ===

namespace ProductReviewAnalyzer.HistoryService.Application.Interfaces;

public interface IUnitOfWork : IDisposable
{
    Task<int> SaveChangesAsync(CancellationToken ct);
}

=== HistoryService\HistoryService.Application\Queries\GetHistoryRecords\GetHistoryRecordsQuery.cs ===

using MediatR;
using ProductReviewAnalyzer.HistoryService.Application.DTOs;

namespace ProductReviewAnalyzer.HistoryService.Application.Queries.GetHistoryRecords;

public record GetHistoryRecordsQuery : IRequest<IReadOnlyList<HistoryRecordDto>>;


=== HistoryService\HistoryService.Application\Queries\GetHistoryRecords\GetHistoryRecordsQueryHandler.cs ===

using MediatR;
using ProductReviewAnalyzer.HistoryService.Application.DTOs;
using ProductReviewAnalyzer.HistoryService.Application.Interfaces;

namespace ProductReviewAnalyzer.HistoryService.Application.Queries.GetHistoryRecords;

public class GetHistoryRecordsQueryHandler(IHistoryRepository repo)
    : IRequestHandler<GetHistoryRecordsQuery, IReadOnlyList<HistoryRecordDto>>
{
    public async Task<IReadOnlyList<HistoryRecordDto>> Handle(GetHistoryRecordsQuery _, CancellationToken ct)
    {
        var list = await repo.ListAsync(null, ct);

        return list.Select(e => new HistoryRecordDto(e.Id, e.Url, e.RequestedAtUtc, e.Status))
            .OrderByDescending(d => d.RequestedAtUtc)
            .ToList();
    }
}

=== HistoryService\HistoryService.Domain\ProductReviewAnalyzer.HistoryService.Domain.csproj ===

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>

=== HistoryService\HistoryService.Domain\Entities\HistoryRecord.cs ===

using ProductReviewAnalyzer.HistoryService.Domain.ValueObjects;

namespace ProductReviewAnalyzer.HistoryService.Domain.Entities;

public class HistoryRecord
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public string Url { get; init; } = default!;
    public DateTime RequestedAtUtc { get; init; }
    public RequestStatus Status { get; set; }
}

=== HistoryService\HistoryService.Domain\ValueObjects\RequestStatus.cs ===

namespace ProductReviewAnalyzer.HistoryService.Domain.ValueObjects;

public enum RequestStatus
{
    Pending = 0,
    Success = 1,
    Failed = 2
}

=== HistoryService\HistoryService.Infrastructure\InfrastructureDependencyInjection.cs ===

using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using ProductReviewAnalyzer.Common.Persistence;
using ProductReviewAnalyzer.HistoryService.Application.Interfaces;
using ProductReviewAnalyzer.HistoryService.Infrastructure.Persistence;

namespace ProductReviewAnalyzer.HistoryService.Infrastructure;

public static class InfrastructureDependencyInjection
{
    public static IServiceCollection AddInfrastructure(this IServiceCollection services, IConfiguration cfg)
    {
        var conn = cfg.GetConnectionString("SqlServer")
                   ?? throw new InvalidOperationException("SqlServer connection string not configured");

        services.AddDbContextWithMigrator<HistoryDbContext>(o =>
            o.UseSqlServer(conn, sql => sql.EnableRetryOnFailure()));

        services.AddScoped<IHistoryRepository, HistoryRepository>();
        services.AddScoped<IUnitOfWork, UnitOfWork>();

        return services;
    }
}

=== HistoryService\HistoryService.Infrastructure\ProductReviewAnalyzer.HistoryService.Infrastructure.csproj ===

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="9.0.5">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" Version="9.0.5" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\Common\ProductReviewAnalyzer.Common.csproj" />
    <ProjectReference Include="..\HistoryService.Application\ProductReviewAnalyzer.HistoryService.Application.csproj" />
  </ItemGroup>

</Project>

=== HistoryService\HistoryService.Infrastructure\Migrations\20250526022944_InitialCreate.cs ===

using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace ProductReviewAnalyzer.HistoryService.Infrastructure.Migrations
{
    /// <inheritdoc />
    public partial class InitialCreate : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "HistoryRecords",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uniqueidentifier", nullable: false),
                    Url = table.Column<string>(type: "nvarchar(2048)", maxLength: 2048, nullable: false),
                    RequestedAtUtc = table.Column<DateTime>(type: "datetime2", nullable: false),
                    Status = table.Column<int>(type: "int", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_HistoryRecords", x => x.Id);
                });
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "HistoryRecords");
        }
    }
}

=== HistoryService\HistoryService.Infrastructure\Migrations\20250526022944_InitialCreate.Designer.cs ===

// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using ProductReviewAnalyzer.HistoryService.Infrastructure.Persistence;

#nullable disable

namespace ProductReviewAnalyzer.HistoryService.Infrastructure.Migrations
{
    [DbContext(typeof(HistoryDbContext))]
    [Migration("20250526022944_InitialCreate")]
    partial class InitialCreate
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.5")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("ProductReviewAnalyzer.HistoryService.Domain.Entities.HistoryRecord", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uniqueidentifier");

                    b.Property<DateTime>("RequestedAtUtc")
                        .HasColumnType("datetime2");

                    b.Property<int>("Status")
                        .HasColumnType("int");

                    b.Property<string>("Url")
                        .IsRequired()
                        .HasMaxLength(2048)
                        .HasColumnType("nvarchar(2048)");

                    b.HasKey("Id");

                    b.ToTable("HistoryRecords", (string)null);
                });
#pragma warning restore 612, 618
        }
    }
}

=== HistoryService\HistoryService.Infrastructure\Migrations\HistoryDbContextModelSnapshot.cs ===

// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using ProductReviewAnalyzer.HistoryService.Infrastructure.Persistence;

#nullable disable

namespace ProductReviewAnalyzer.HistoryService.Infrastructure.Migrations
{
    [DbContext(typeof(HistoryDbContext))]
    partial class HistoryDbContextModelSnapshot : ModelSnapshot
    {
        protected override void BuildModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.5")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("ProductReviewAnalyzer.HistoryService.Domain.Entities.HistoryRecord", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uniqueidentifier");

                    b.Property<DateTime>("RequestedAtUtc")
                        .HasColumnType("datetime2");

                    b.Property<int>("Status")
                        .HasColumnType("int");

                    b.Property<string>("Url")
                        .IsRequired()
                        .HasMaxLength(2048)
                        .HasColumnType("nvarchar(2048)");

                    b.HasKey("Id");

                    b.ToTable("HistoryRecords", (string)null);
                });
#pragma warning restore 612, 618
        }
    }
}

=== HistoryService\HistoryService.Infrastructure\Persistence\HistoryDbContext.cs ===

using Microsoft.EntityFrameworkCore;
using ProductReviewAnalyzer.HistoryService.Domain.Entities;

namespace ProductReviewAnalyzer.HistoryService.Infrastructure.Persistence;

public class HistoryDbContext(DbContextOptions<HistoryDbContext> options) : DbContext(options)
{
    public DbSet<HistoryRecord> HistoryRecords => Set<HistoryRecord>();

    protected override void OnModelCreating(ModelBuilder b)
    {
        b.Entity<HistoryRecord>(cfg =>
        {
            cfg.ToTable("HistoryRecords");
            cfg.HasKey(h => h.Id);
            cfg.Property(h => h.Url).IsRequired().HasMaxLength(2048);
            cfg.Property(h => h.Status).IsRequired();
            cfg.Property(h => h.RequestedAtUtc).IsRequired();
        });
    }
}

=== HistoryService\HistoryService.Infrastructure\Persistence\HistoryRepository.cs ===

using Microsoft.EntityFrameworkCore;
using ProductReviewAnalyzer.HistoryService.Application.Interfaces;
using ProductReviewAnalyzer.HistoryService.Domain.Entities;
using System.Linq.Expressions;

namespace ProductReviewAnalyzer.HistoryService.Infrastructure.Persistence;

internal sealed class HistoryRepository(HistoryDbContext db) : IHistoryRepository
{
    public async Task AddAsync(HistoryRecord entity, CancellationToken ct)
    {
        await db.HistoryRecords.AddAsync(entity, ct);
    }

    public async Task<IReadOnlyList<HistoryRecord>> ListAsync(Expression<Func<HistoryRecord, bool>>? filter, CancellationToken ct)
    {
        IQueryable<HistoryRecord> query = db.HistoryRecords.AsNoTracking();
        if (filter is not null)
            query = query.Where(filter);
        return await query.ToListAsync(ct);
    }
}

=== HistoryService\HistoryService.Infrastructure\Persistence\UnitOfWork.cs ===

using ProductReviewAnalyzer.HistoryService.Application.Interfaces;

namespace ProductReviewAnalyzer.HistoryService.Infrastructure.Persistence;

internal sealed class UnitOfWork(HistoryDbContext db) : IUnitOfWork
{
    public Task<int> SaveChangesAsync(CancellationToken ct) => db.SaveChangesAsync(ct);
    public void Dispose() => db.Dispose();
}

=== ReviewsScraper.Rozetka\appsettings.json ===

{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "MassTransit": "Debug",
      "MassTransit.RabbitMqTransport": "Debug"
    }
  },
  "MassTransit": {
    "Host": null,
    "Username": null,
    "Password": null
  },
  "RabbitMq": {
    "Host": null,
    "VirtualHost": "/",
    "Username": null,
    "Password": null,
    "Exchange": "reviews.fetched"
  },
  "RozetkaApi": {
    "BaseUrl": null
  },
  "ConnectionStrings": {
    "Db": null
  },
  "Cache": {
    "Redis": null
  }
}

=== ReviewsScraper.Rozetka\Dockerfile ===

FROM mcr.microsoft.com/dotnet/aspnet:9.0 AS base
USER $APP_UID
WORKDIR /app


FROM mcr.microsoft.com/dotnet/sdk:9.0 AS build
ARG BUILD_CONFIGURATION=Release
WORKDIR /src
COPY ["ReviewsScraper.Rozetka/ProductReviewAnalyzer.ReviewsScraper.Rozetka.csproj", "ReviewsScraper.Rozetka/"]
COPY ["Common/ProductReviewAnalyzer.Common.csproj", "Common/"]
COPY ["Contracts/ProductReviewAnalyzer.Contracts.csproj", "Contracts/"]
RUN dotnet restore "./ReviewsScraper.Rozetka/ProductReviewAnalyzer.ReviewsScraper.Rozetka.csproj"
COPY . .
WORKDIR "/src/ReviewsScraper.Rozetka"
RUN dotnet build "./ProductReviewAnalyzer.ReviewsScraper.Rozetka.csproj" -c $BUILD_CONFIGURATION -o /app/build

FROM build AS publish
ARG BUILD_CONFIGURATION=Release
RUN dotnet publish "./ProductReviewAnalyzer.ReviewsScraper.Rozetka.csproj" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "ProductReviewAnalyzer.ReviewsScraper.Rozetka.dll"]

=== ReviewsScraper.Rozetka\ProductReviewAnalyzer.ReviewsScraper.Rozetka.csproj ===

<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <DockerDefaultTargetOS>Linux</DockerDefaultTargetOS>
    <DockerComposeProjectPath>..\docker-compose.dcproj</DockerComposeProjectPath>
    <UserSecretsId>781f9965-4f0a-4e2e-8b19-5b024f881c35</UserSecretsId>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="AutoMapper" Version="14.0.0" />
    <PackageReference Include="FluentValidation" Version="12.0.0" />
    <PackageReference Include="FluentValidation.DependencyInjectionExtensions" Version="12.0.0" />
    <PackageReference Include="HtmlAgilityPack" Version="1.12.1" />
    <PackageReference Include="MassTransit" Version="8.4.1" />
    <PackageReference Include="MassTransit.RabbitMQ" Version="8.4.1" />
    <PackageReference Include="MediatR" Version="12.5.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="9.0.5" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="9.0.5">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" Version="9.0.5" />
    <PackageReference Include="Microsoft.VisualStudio.Azure.Containers.Tools.Targets" Version="1.21.0" />
    <PackageReference Include="Refit.HttpClientFactory" Version="8.0.0" />
    <PackageReference Include="Swashbuckle.AspNetCore" Version="8.1.2" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\Common\ProductReviewAnalyzer.Common.csproj" />
    <ProjectReference Include="..\Contracts\ProductReviewAnalyzer.Contracts.csproj" />
  </ItemGroup>

</Project>

=== ReviewsScraper.Rozetka\ProductReviewAnalyzer.ReviewsScraper.Rozetka.csproj.user ===

<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ActiveDebugProfile>Container (Dockerfile)</ActiveDebugProfile>
  </PropertyGroup>
</Project>

=== ReviewsScraper.Rozetka\Program.cs ===

using ProductReviewAnalyzer.ReviewsScraper.Rozetka.Application;
using ProductReviewAnalyzer.ReviewsScraper.Rozetka.Infrastructure;
using ProductReviewAnalyzer.ReviewsScraper.Rozetka.API.Filters;
using MassTransit;
using ProductReviewAnalyzer.Common.Persistence;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllers(options =>
{
    options.Filters.Add<ValidationExceptionFilter>();
});

builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

builder.Services.AddApplication();
builder.Services.AddInfrastructure(builder.Configuration);

builder.Services.AddMassTransit(cfg =>
{
    cfg.UsingRabbitMq((ctx, busCfg) =>
    {
        var mq = builder.Configuration.GetSection("RabbitMq");
        busCfg.Host(mq["Host"], mq["VirtualHost"], h =>
        {
            h.Username(mq["Username"]);
            h.Password(mq["Password"]);
        });

        busCfg.ConfigureEndpoints(ctx);
    });
});

var app = builder.Build();

app.UseSwagger();
app.UseSwaggerUI();

using (var scope = app.Services.CreateScope())
{
    var migrators = scope.ServiceProvider.GetServices<IDatabaseMigrator>();
    foreach (var migrator in migrators)
    {
        await migrator.MigrateAsync();
    }
}

app.MapControllers();
app.Run();

=== ReviewsScraper.Rozetka\API\Controllers\ScraperController.cs ===

using MediatR;
using Microsoft.AspNetCore.Mvc;
using ProductReviewAnalyzer.ReviewsScraper.Rozetka.Application.Commands.FetchReviews;

namespace ProductReviewAnalyzer.ReviewsScraper.Rozetka.API.Controllers;

[ApiController]
[Route("api/scraper/rozetka")]
public sealed class ScraperController(IMediator mediator) : ControllerBase
{
    [HttpPost("reviews")]
    public async Task<IActionResult> FetchAll([FromBody] UrlDto dto, CancellationToken ct)
    {
        var count = await mediator.Send(new FetchReviewsCommand(dto.Url), ct);
        return Ok(new { Added = count });
    }

    public record UrlDto(string Url);
}

=== ReviewsScraper.Rozetka\API\Filters\ValidationExceptionFilter.cs ===

using FluentValidation;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.Filters;

namespace ProductReviewAnalyzer.ReviewsScraper.Rozetka.API.Filters;

public sealed class ValidationExceptionFilter : IExceptionFilter
{
    public void OnException(ExceptionContext ctx)
    {
        if (ctx.Exception is not ValidationException ex) return;

        ctx.Result = new BadRequestObjectResult(new
        {
            Errors = ex.Errors.Select(e => e.ErrorMessage)
        });
        ctx.ExceptionHandled = true;
    }
}

=== ReviewsScraper.Rozetka\Application\DependencyInjection.cs ===

using FluentValidation;
using MediatR;
using ProductReviewAnalyzer.ReviewsScraper.Rozetka.Application.Behaviors;
using System.Reflection;

namespace ProductReviewAnalyzer.ReviewsScraper.Rozetka.Application;

public static class DependencyInjection
{
    public static IServiceCollection AddApplication(this IServiceCollection services)
    {
        var assembly = Assembly.GetExecutingAssembly();

        services.AddMediatR(cfg => cfg.RegisterServicesFromAssembly(assembly));
        services.AddValidatorsFromAssembly(assembly);

        services.AddTransient(typeof(IPipelineBehavior<,>), typeof(ValidationBehavior<,>));
        services.AddTransient(typeof(IPipelineBehavior<,>), typeof(LoggingBehavior<,>));

        return services;
    }
}

=== ReviewsScraper.Rozetka\Application\Behaviors\LoggingBehavior.cs ===

using MediatR;

namespace ProductReviewAnalyzer.ReviewsScraper.Rozetka.Application.Behaviors;

public sealed class LoggingBehavior<TRequest, TResponse>(ILogger<LoggingBehavior<TRequest, TResponse>> logger)
    : IPipelineBehavior<TRequest, TResponse> where TRequest : notnull
{
    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken ct)
    {
        logger.LogDebug("Handling {Request}", typeof(TRequest).Name);
        var response = await next(ct);
        logger.LogDebug("Handled {Request}", typeof(TRequest).Name);
        return response;
    }
}

=== ReviewsScraper.Rozetka\Application\Behaviors\ValidationBehavior.cs ===

using FluentValidation;
using MediatR;

namespace ProductReviewAnalyzer.ReviewsScraper.Rozetka.Application.Behaviors;

public sealed class ValidationBehavior<TRequest, TResponse>(IEnumerable<IValidator<TRequest>> validators)
    : IPipelineBehavior<TRequest, TResponse>
    where TRequest : notnull
{
    public async Task<TResponse> Handle(
        TRequest request,
        RequestHandlerDelegate<TResponse> next,
        CancellationToken cancellationToken)
    {
        if (!validators.Any()) return await next(cancellationToken);

        var context = new ValidationContext<TRequest>(request);
        var validationResults = await Task.WhenAll(
            validators.Select(v => v.ValidateAsync(context, cancellationToken))
        );
        var failures = validationResults
            .SelectMany(r => r.Errors)
            .Where(f => f != null)
            .ToList();

        if (failures.Any())
            throw new ValidationException(failures);

        return await next(cancellationToken);
    }
}

=== ReviewsScraper.Rozetka\Application\Commands\FetchReviews\FetchReviewsCommand.cs ===

using MediatR;

namespace ProductReviewAnalyzer.ReviewsScraper.Rozetka.Application.Commands.FetchReviews;

public sealed record FetchReviewsCommand(string ProductUrl) : IRequest<int>;

=== ReviewsScraper.Rozetka\Application\Commands\FetchReviews\FetchReviewsCommandHandler.cs ===

using MediatR;
using Microsoft.EntityFrameworkCore;
using ProductReviewAnalyzer.ReviewsScraper.Rozetka.Infrastructure.Messaging;
using ProductReviewAnalyzer.ReviewsScraper.Rozetka.Infrastructure.Persistence;
using ProductReviewAnalyzer.ReviewsScraper.Rozetka.Infrastructure.Services;
using System.Text.RegularExpressions;

namespace ProductReviewAnalyzer.ReviewsScraper.Rozetka.Application.Commands.FetchReviews;

public sealed class FetchReviewsCommandHandler(
    IRozetkaApi api,
    HtmlParser parser,
    RozetkaDbContext db,
    IReviewPublisher publisher,
    ILogger<FetchReviewsCommandHandler> logger)
    : IRequestHandler<FetchReviewsCommand, int>
{
    private const int PageSize = 36;

    public async Task<int> Handle(FetchReviewsCommand request, CancellationToken ct)
    {
        if (!TryExtractProductId(request.ProductUrl, out var productId))
            throw new ArgumentException($"–ù–µ –≤–¥–∞–ª–æ—Å—è –≤–∏–∑–Ω–∞—á–∏—Ç–∏ productId –∑ URL {request.ProductUrl}");

        int page = 1, added = 0;
        while (true)
        {
            var apiResp = await api.GetCommentsAsync(productId, page, ct);
            var reviews = parser.Parse(apiResp).ToList();
            if (reviews.Count == 0) break;

            foreach (var r in reviews)
            {
                if (await db.Reviews.AsNoTracking()
                        .AnyAsync(x => x.ExternalId == r.ExternalId, ct))
                    continue;

                db.Reviews.Add(r);
                await publisher.PublishAsync(r, ct);
                added++;
            }

            await db.SaveChangesAsync(ct);

            if (reviews.Count < PageSize) break;
            page++;
        }

        logger.LogInformation("Loaded {Count} new reviews for product {ProductId}", added, productId);
        return added;
    }

    private static bool TryExtractProductId(string url, out long productId)
    {
        productId = 0;
        var match = Regex.Match(url, @"(?:p|goods=)(\d+)");
        return match.Success && long.TryParse(match.Groups[1].Value, out productId);
    }
}

=== ReviewsScraper.Rozetka\Application\Commands\FetchReviews\FetchReviewsCommandValidator.cs ===

using FluentValidation;

namespace ProductReviewAnalyzer.ReviewsScraper.Rozetka.Application.Commands.FetchReviews;

public sealed class FetchReviewsCommandValidator : AbstractValidator<FetchReviewsCommand>
{
    public FetchReviewsCommandValidator()
    {
        RuleFor(x => x.ProductUrl)
            .NotEmpty()
            .Must(url => Uri.TryCreate(url, UriKind.Absolute, out var u) && u.Scheme.StartsWith("http"))
            .WithMessage("–ù–µ–≤–∞–ª—ñ–¥–Ω–∏–π URL");
    }
}

=== ReviewsScraper.Rozetka\Application\DTOs\ReviewDto.cs ===

namespace ProductReviewAnalyzer.ReviewsScraper.Rozetka.Application.DTOs;

public record ReviewDto(
    long Id,
    long ProductId,
    string UserTitle,
    int Mark,
    string Text,
    bool FromBuyer,
    DateTime CreatedAt);

=== ReviewsScraper.Rozetka\Application\Mapping\MappingProfile.cs ===

using AutoMapper;
using ProductReviewAnalyzer.ReviewsScraper.Rozetka.Domain.Entities;
using ProductReviewAnalyzer.ReviewsScraper.Rozetka.Application.DTOs;

namespace ProductReviewAnalyzer.ReviewsScraper.Rozetka.Application.Mapping;

public class MappingProfile : Profile
{
    public MappingProfile()
    {
        CreateMap<Review, ReviewDto>();
    }
}

=== ReviewsScraper.Rozetka\Application\Queries\GetReviews\GetReviewsQuery.cs ===

using MediatR;
using ProductReviewAnalyzer.ReviewsScraper.Rozetka.Application.DTOs;

namespace ProductReviewAnalyzer.ReviewsScraper.Rozetka.Application.Queries.GetReviews;

public sealed record GetReviewsQuery(long ProductId) : IRequest<IReadOnlyList<ReviewDto>>;

=== ReviewsScraper.Rozetka\Application\Queries\GetReviews\GetReviewsQueryHandler.cs ===

using AutoMapper;
using MediatR;
using Microsoft.EntityFrameworkCore;
using ProductReviewAnalyzer.ReviewsScraper.Rozetka.Application.DTOs;
using ProductReviewAnalyzer.ReviewsScraper.Rozetka.Infrastructure.Persistence;

namespace ProductReviewAnalyzer.ReviewsScraper.Rozetka.Application.Queries.GetReviews;

public sealed class GetReviewsQueryHandler(RozetkaDbContext db, IMapper mapper)
    : IRequestHandler<GetReviewsQuery, IReadOnlyList<ReviewDto>>
{
    public async Task<IReadOnlyList<ReviewDto>> Handle(GetReviewsQuery request, CancellationToken cancellationToken)
    {
        var reviews = await db.Reviews
            .Where(r => r.ProductId == request.ProductId)
            .OrderByDescending(r => r.CreatedAt)
            .ToListAsync(cancellationToken);

        return reviews.Select(mapper.Map<ReviewDto>).ToList();
    }
}

=== ReviewsScraper.Rozetka\Domain\Entities\Attachment.cs ===

using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace ProductReviewAnalyzer.ReviewsScraper.Rozetka.Domain.Entities;

public class Attachment
{
    [Key]
    [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
    public int Id { get; set; }

    public int ReviewId { get; set; }

    [Required]
    public long ExternalId { get; set; }

    public string Url { get; set; } = default!;
    public int Width { get; set; }
    public int Height { get; set; }
}

=== ReviewsScraper.Rozetka\Domain\Entities\Review.cs ===

using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace ProductReviewAnalyzer.ReviewsScraper.Rozetka.Domain.Entities;

public class Review
{
    [Key]
    [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
    public int Id { get; set; }

    [Required]
    public long ExternalId { get; set; }

    public long ProductId { get; set; }
    public string UserTitle { get; set; } = default!;
    public int? Mark { get; set; }
    public string Text { get; set; } = default!;
    public string? Dignity { get; set; }
    public string? Shortcomings { get; set; }
    public bool FromBuyer { get; set; }
    public DateTime CreatedAt { get; set; }
    public ICollection<Attachment> Attachments { get; set; } = [];
}

=== ReviewsScraper.Rozetka\Domain\ValueObjects\Attachment.cs ===

namespace ProductReviewAnalyzer.ReviewsScraper.Rozetka.Domain.ValueObjects;

public class Attachment
{
    public long Id { get; set; }
    public long ReviewId { get; set; }
    public string Url { get; set; } = default!;
    public int Width { get; set; }
    public int Height { get; set; }
}

=== ReviewsScraper.Rozetka\Infrastructure\DependencyInjection.cs ===

using MediatR;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Caching.Memory;
using ProductReviewAnalyzer.Common.Persistence;
using ProductReviewAnalyzer.ReviewsScraper.Rozetka.Application.Behaviors;
using ProductReviewAnalyzer.ReviewsScraper.Rozetka.Infrastructure.Messaging;
using ProductReviewAnalyzer.ReviewsScraper.Rozetka.Infrastructure.Persistence;
using ProductReviewAnalyzer.ReviewsScraper.Rozetka.Infrastructure.Services;
using Refit;
using System.Net;
using System.Reflection;

namespace ProductReviewAnalyzer.ReviewsScraper.Rozetka.Infrastructure;

public static class DependencyInjection
{
    public static IServiceCollection AddInfrastructure(this IServiceCollection services, IConfiguration config)
    {
        var asm = Assembly.GetExecutingAssembly();

        var conn = config.GetConnectionString("SqlServer")
                   ?? throw new InvalidOperationException("SqlServer connection string not configured");

        services.AddDbContextWithMigrator<RozetkaDbContext>(opt =>
            opt.UseSqlServer(conn));

        services.AddRefitClient<IRozetkaApi>()
            .ConfigureHttpClient(c =>
            {
                c.BaseAddress = new Uri(config["RozetkaApi:BaseUrl"]!);
            })
            .ConfigurePrimaryHttpMessageHandler(() =>
                new HttpClientHandler { AutomaticDecompression = DecompressionMethods.All }
            );

        services.AddMemoryCache();
        services.AddTransient<IRozetkaApi>(sp =>
        {
            var inner = RestService.For<IRozetkaApi>(new HttpClient
            {
                BaseAddress = new Uri(config["RozetkaApi:BaseUrl"]!)
            });
            var cache = sp.GetRequiredService<IMemoryCache>();
            var log = sp.GetRequiredService<ILogger<RozetkaApiClient>>();
            return new RozetkaApiClient(inner, cache, log);
        });

        services.AddSingleton<HtmlParser>();

        services.AddScoped<IReviewPublisher, ReviewPublisher>();

        services.AddAutoMapper(asm);

        services.AddScoped(typeof(IPipelineBehavior<,>), typeof(ValidationBehavior<,>));
        services.AddScoped(typeof(IPipelineBehavior<,>), typeof(LoggingBehavior<,>));

        return services;
    }
}

=== ReviewsScraper.Rozetka\Infrastructure\Messaging\ReviewPublisher.cs ===

using MassTransit;
using ProductReviewAnalyzer.Contracts;
using ProductReviewAnalyzer.ReviewsScraper.Rozetka.Domain.Entities;

namespace ProductReviewAnalyzer.ReviewsScraper.Rozetka.Infrastructure.Messaging;

public interface IReviewPublisher
{
    Task PublishAsync(Review review, CancellationToken ct);
}

public sealed class ReviewPublisher(IPublishEndpoint bus, ILogger<ReviewPublisher> logger) : IReviewPublisher
{
    public Task PublishAsync(Review review, CancellationToken ct)
    {
        var evt = new NewReviewReceived(
            review.Id,
            review.ProductId,
            review.UserTitle,
            review.Mark,
            review.Text,
            review.Dignity,
            review.Shortcomings,
            review.FromBuyer,
            review.CreatedAt);

        logger.LogDebug("Publishing NewReviewReceived for review {ReviewId}", review.Id);
        return bus.Publish(evt, ct);
    }
}

=== ReviewsScraper.Rozetka\Infrastructure\Persistence\RozetkaDbContext.cs ===

using Microsoft.EntityFrameworkCore;
using ProductReviewAnalyzer.ReviewsScraper.Rozetka.Domain.Entities;

namespace ProductReviewAnalyzer.ReviewsScraper.Rozetka.Infrastructure.Persistence;

public class RozetkaDbContext(DbContextOptions<RozetkaDbContext> options) : DbContext(options)
{
    public DbSet<Review> Reviews => Set<Review>();
    public DbSet<Attachment> Attachments => Set<Attachment>();

    protected override void OnModelCreating(ModelBuilder b)
    {
        b.Entity<Review>(cfg =>
        {
            cfg.HasKey(x => x.Id);

            cfg.HasIndex(x => x.ExternalId).IsUnique();

            cfg.Property(x => x.Text).HasColumnType("nvarchar(max)");
            cfg.Property(x => x.Dignity).HasColumnType("nvarchar(max)");
            cfg.Property(x => x.Shortcomings).HasColumnType("nvarchar(max)");
            cfg.HasMany(x => x.Attachments)
                .WithOne()
                .HasForeignKey(a => a.ReviewId)
                .OnDelete(DeleteBehavior.Cascade);
        });

        b.Entity<Attachment>(cfg =>
        {
            cfg.HasKey(x => x.Id);
            cfg.HasIndex(x => x.ExternalId).IsUnique();
        });
    }
}

=== ReviewsScraper.Rozetka\Infrastructure\Services\HtmlParser.cs ===

using HtmlAgilityPack;
using ProductReviewAnalyzer.ReviewsScraper.Rozetka.Domain.Entities;
using System.Globalization;

namespace ProductReviewAnalyzer.ReviewsScraper.Rozetka.Infrastructure.Services;

public sealed class HtmlParser
{
    private static readonly CultureInfo UkCulture = new CultureInfo("uk-UA");
    private static readonly string[] DateFormats = { "d MMMM yyyy", "dd MMMM yyyy" };

    public IEnumerable<Review> Parse(RozetkaCommentsResponse resp)
    {
        foreach (var c in resp.data.comments)
        {
            var dateStr = c.created.pop_date;
            if (!DateTime.TryParseExact(dateStr, DateFormats, UkCulture, DateTimeStyles.None, out var createdAt))
            {
                createdAt = DateTime.Parse(dateStr, UkCulture);
            }

            yield return new Review
            {
                ExternalId = c.id,
                ProductId = long.Parse(c.goods_id),
                UserTitle = HtmlEntity.DeEntitize(c.usertitle),
                Mark = c.mark,
                Text = HtmlEntity.DeEntitize(c.text),
                Dignity = string.IsNullOrWhiteSpace(c.dignity) ? null
                    : HtmlEntity.DeEntitize(c.dignity),
                Shortcomings = string.IsNullOrWhiteSpace(c.shortcomings) ? null
                    : HtmlEntity.DeEntitize(c.shortcomings),
                FromBuyer = c.from_buyer,
                CreatedAt = createdAt,
                Attachments = c.attachments.Select(a => new Attachment
                {
                    ExternalId = a.id,
                    Url = a.preview.src,
                    Width = a.preview.width,
                    Height = a.preview.height
                }).ToList()
            };

        }
    }
}

=== ReviewsScraper.Rozetka\Infrastructure\Services\IRozetkaApi.cs ===

using Refit;

namespace ProductReviewAnalyzer.ReviewsScraper.Rozetka.Infrastructure.Services;

public interface IRozetkaApi
{
    [Get("/v4/comments/get?country=UA&lang=ua&type=comment&limit=36&sort=from_buyer&topSellerId=5&goods={goods}&page={page}")]
    Task<RozetkaCommentsResponse> GetCommentsAsync([AliasAs("goods")] long goods, [AliasAs("page")] int page = 1, CancellationToken ct = default);
}

=== ReviewsScraper.Rozetka\Infrastructure\Services\RozetkaApiClient.cs ===

using Microsoft.Extensions.Caching.Memory;

namespace ProductReviewAnalyzer.ReviewsScraper.Rozetka.Infrastructure.Services;

public sealed class RozetkaApiClient(IRozetkaApi inner, IMemoryCache cache, ILogger<RozetkaApiClient> logger)
    : IRozetkaApi
{
    private readonly MemoryCacheEntryOptions _opts = new()
    {
        AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(5)
    };

    public Task<RozetkaCommentsResponse> GetCommentsAsync(long goods, int page = 1, CancellationToken ct = default)
    {
        var key = $"rz-{goods}-p{page}";
        return cache.GetOrCreateAsync(key, async _ =>
        {
            logger.LogInformation("Cache MISS for {Key}", key);
            return await inner.GetCommentsAsync(goods, page, ct);
        })!;
    }
}

=== ReviewsScraper.Rozetka\Infrastructure\Services\RozetkaApiModels.cs ===

using System.Text.Json;
using System.Text.Json.Serialization;

namespace ProductReviewAnalyzer.ReviewsScraper.Rozetka.Infrastructure.Services;

public sealed class RozetkaCommentsResponse
{
    public required Data data { get; init; }

    public sealed class Data
    {
        public required Comment[] comments { get; init; }
    }

    public sealed class Comment
    {
        public long id { get; init; }
        public string goods_id { get; init; } = string.Empty;
        public string usertitle { get; init; } = string.Empty;
        [JsonConverter(typeof(NullableIntConverter))]
        public int? mark { get; init; }
        public string text { get; init; } = string.Empty;
        public string dignity { get; init; } = string.Empty;
        public string shortcomings { get; init; } = string.Empty;
        public bool from_buyer { get; init; }
        public Created created { get; init; } = new();
        public AttachmentDto[] attachments { get; init; } = [];
    }

    public sealed class Created
    {
        public string pop_date { get; init; } = string.Empty;
    }

    public sealed class AttachmentDto
    {
        public long id { get; init; }
        public Preview preview { get; init; } = new();
        public sealed class Preview { public string src { get; init; } = string.Empty; public int width { get; init; } public int height { get; init; } }
    }

    private sealed class NullableIntConverter : JsonConverter<int?>
    {
        public override int? Read(ref Utf8JsonReader r, Type t, JsonSerializerOptions o)
        {
            return r.TokenType switch
            {
                JsonTokenType.Number => r.GetInt32(),
                JsonTokenType.String when int.TryParse(r.GetString(), out var v) => v,
                JsonTokenType.Null => null,
                _ => null
            };
        }
        public override void Write(Utf8JsonWriter w, int? v, JsonSerializerOptions o) =>
            w.WriteNumberValue(v ?? 0);
    }
}

=== ReviewsScraper.Rozetka\Migrations\20250526081807_InitialCreate.cs ===

using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace ProductReviewAnalyzer.ReviewsScraper.Rozetka.Migrations
{
    /// <inheritdoc />
    public partial class InitialCreate : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "Reviews",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    ExternalId = table.Column<long>(type: "bigint", nullable: false),
                    ProductId = table.Column<long>(type: "bigint", nullable: false),
                    UserTitle = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Mark = table.Column<int>(type: "int", nullable: true),
                    Text = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Dignity = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    Shortcomings = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    FromBuyer = table.Column<bool>(type: "bit", nullable: false),
                    CreatedAt = table.Column<DateTime>(type: "datetime2", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Reviews", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "Attachments",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    ReviewId = table.Column<int>(type: "int", nullable: false),
                    ExternalId = table.Column<long>(type: "bigint", nullable: false),
                    Url = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Width = table.Column<int>(type: "int", nullable: false),
                    Height = table.Column<int>(type: "int", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Attachments", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Attachments_Reviews_ReviewId",
                        column: x => x.ReviewId,
                        principalTable: "Reviews",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateIndex(
                name: "IX_Attachments_ExternalId",
                table: "Attachments",
                column: "ExternalId",
                unique: true);

            migrationBuilder.CreateIndex(
                name: "IX_Attachments_ReviewId",
                table: "Attachments",
                column: "ReviewId");

            migrationBuilder.CreateIndex(
                name: "IX_Reviews_ExternalId",
                table: "Reviews",
                column: "ExternalId",
                unique: true);
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "Attachments");

            migrationBuilder.DropTable(
                name: "Reviews");
        }
    }
}

=== ReviewsScraper.Rozetka\Migrations\20250526081807_InitialCreate.Designer.cs ===

// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using ProductReviewAnalyzer.ReviewsScraper.Rozetka.Infrastructure.Persistence;

#nullable disable

namespace ProductReviewAnalyzer.ReviewsScraper.Rozetka.Migrations
{
    [DbContext(typeof(RozetkaDbContext))]
    [Migration("20250526081807_InitialCreate")]
    partial class InitialCreate
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.5")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("ProductReviewAnalyzer.ReviewsScraper.Rozetka.Domain.Entities.Attachment", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<long>("ExternalId")
                        .HasColumnType("bigint");

                    b.Property<int>("Height")
                        .HasColumnType("int");

                    b.Property<int>("ReviewId")
                        .HasColumnType("int");

                    b.Property<string>("Url")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("Width")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("ExternalId")
                        .IsUnique();

                    b.HasIndex("ReviewId");

                    b.ToTable("Attachments");
                });

            modelBuilder.Entity("ProductReviewAnalyzer.ReviewsScraper.Rozetka.Domain.Entities.Review", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Dignity")
                        .HasColumnType("nvarchar(max)");

                    b.Property<long>("ExternalId")
                        .HasColumnType("bigint");

                    b.Property<bool>("FromBuyer")
                        .HasColumnType("bit");

                    b.Property<int?>("Mark")
                        .HasColumnType("int");

                    b.Property<long>("ProductId")
                        .HasColumnType("bigint");

                    b.Property<string>("Shortcomings")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Text")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("UserTitle")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("ExternalId")
                        .IsUnique();

                    b.ToTable("Reviews");
                });

            modelBuilder.Entity("ProductReviewAnalyzer.ReviewsScraper.Rozetka.Domain.Entities.Attachment", b =>
                {
                    b.HasOne("ProductReviewAnalyzer.ReviewsScraper.Rozetka.Domain.Entities.Review", null)
                        .WithMany("Attachments")
                        .HasForeignKey("ReviewId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("ProductReviewAnalyzer.ReviewsScraper.Rozetka.Domain.Entities.Review", b =>
                {
                    b.Navigation("Attachments");
                });
#pragma warning restore 612, 618
        }
    }
}

=== ReviewsScraper.Rozetka\Migrations\RozetkaDbContextModelSnapshot.cs ===

// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using ProductReviewAnalyzer.ReviewsScraper.Rozetka.Infrastructure.Persistence;

#nullable disable

namespace ProductReviewAnalyzer.ReviewsScraper.Rozetka.Migrations
{
    [DbContext(typeof(RozetkaDbContext))]
    partial class RozetkaDbContextModelSnapshot : ModelSnapshot
    {
        protected override void BuildModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.5")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("ProductReviewAnalyzer.ReviewsScraper.Rozetka.Domain.Entities.Attachment", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<long>("ExternalId")
                        .HasColumnType("bigint");

                    b.Property<int>("Height")
                        .HasColumnType("int");

                    b.Property<int>("ReviewId")
                        .HasColumnType("int");

                    b.Property<string>("Url")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("Width")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("ExternalId")
                        .IsUnique();

                    b.HasIndex("ReviewId");

                    b.ToTable("Attachments");
                });

            modelBuilder.Entity("ProductReviewAnalyzer.ReviewsScraper.Rozetka.Domain.Entities.Review", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Dignity")
                        .HasColumnType("nvarchar(max)");

                    b.Property<long>("ExternalId")
                        .HasColumnType("bigint");

                    b.Property<bool>("FromBuyer")
                        .HasColumnType("bit");

                    b.Property<int?>("Mark")
                        .HasColumnType("int");

                    b.Property<long>("ProductId")
                        .HasColumnType("bigint");

                    b.Property<string>("Shortcomings")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Text")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("UserTitle")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("ExternalId")
                        .IsUnique();

                    b.ToTable("Reviews");
                });

            modelBuilder.Entity("ProductReviewAnalyzer.ReviewsScraper.Rozetka.Domain.Entities.Attachment", b =>
                {
                    b.HasOne("ProductReviewAnalyzer.ReviewsScraper.Rozetka.Domain.Entities.Review", null)
                        .WithMany("Attachments")
                        .HasForeignKey("ReviewId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("ProductReviewAnalyzer.ReviewsScraper.Rozetka.Domain.Entities.Review", b =>
                {
                    b.Navigation("Attachments");
                });
#pragma warning restore 612, 618
        }
    }
}

=== ReviewsScraper.Rozetka\Properties\launchSettings.json ===

{
  "profiles": {
    "ReviewsScraper.Rozetka": {
      "commandName": "Project",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "applicationUrl": "https://localhost:55769;http://localhost:55770"
    },
    "Container (Dockerfile)": {
      "commandName": "Docker",
      "launchBrowser": true,
      "launchUrl": "{Scheme}://{ServiceHost}:{ServicePort}",
      "environmentVariables": {
        "ASPNETCORE_HTTPS_PORTS": "8081",
        "ASPNETCORE_HTTP_PORTS": "8080"
      },
      "publishAllPorts": true,
      "useSSL": true
    }
  }
}

=== TableauExporterService\TableauExporterService.API\appsettings.Development.json ===

{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}

=== TableauExporterService\TableauExporterService.API\appsettings.json ===

{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning"
    }
  },
  "Tableau": {
    "BaseUrl": null,
    "ApiToken": null,
    "SiteId": ""
  },
  "ConnectionStrings": {
    "RabbitMQ": null,
    "Mongo": null
  }
}

=== TableauExporterService\TableauExporterService.API\Dockerfile ===

FROM mcr.microsoft.com/dotnet/aspnet:9.0 AS base
USER $APP_UID
WORKDIR /app


FROM mcr.microsoft.com/dotnet/sdk:9.0 AS build
ARG BUILD_CONFIGURATION=Release
WORKDIR /src
COPY ["TableauExporterService/TableauExporterService.API/ProductReviewAnalyzer.TableauExporterService.API.csproj", "TableauExporterService/TableauExporterService.API/"]
COPY ["TableauExporterService/TableauExporterService.Features/ProductReviewAnalyzer.TableauExporterService.Features.csproj", "TableauExporterService/TableauExporterService.Features/"]
COPY ["Contracts/ProductReviewAnalyzer.Contracts.csproj", "Contracts/"]
COPY ["TableauExporterService/TableauExporterService.Infrastructure/ProductReviewAnalyzer.TableauExporterService.Infrastructure.csproj", "TableauExporterService/TableauExporterService.Infrastructure/"]
RUN dotnet restore "./TableauExporterService/TableauExporterService.API/ProductReviewAnalyzer.TableauExporterService.API.csproj"
COPY . .
WORKDIR "/src/TableauExporterService/TableauExporterService.API"
RUN dotnet build "./ProductReviewAnalyzer.TableauExporterService.API.csproj" -c $BUILD_CONFIGURATION -o /app/build

FROM build AS publish
ARG BUILD_CONFIGURATION=Release
RUN dotnet publish "./ProductReviewAnalyzer.TableauExporterService.API.csproj" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "ProductReviewAnalyzer.TableauExporterService.API.dll"]

=== TableauExporterService\TableauExporterService.API\ProductReviewAnalyzer.TableauExporterService.API.csproj ===

<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <UserSecretsId>950a9c4d-ef4a-49dd-94d6-f3d0df254db5</UserSecretsId>
    <DockerDefaultTargetOS>Linux</DockerDefaultTargetOS>
    <DockerfileContext>..\..</DockerfileContext>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="AspNetCore.HealthChecks.MongoDb" Version="9.0.0" />
    <PackageReference Include="MassTransit.RabbitMQ" Version="8.4.1" />
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="9.0.0" />
    <PackageReference Include="Microsoft.VisualStudio.Azure.Containers.Tools.Targets" Version="1.21.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\TableauExporterService.Features\ProductReviewAnalyzer.TableauExporterService.Features.csproj" />
    <ProjectReference Include="..\TableauExporterService.Infrastructure\ProductReviewAnalyzer.TableauExporterService.Infrastructure.csproj" />
  </ItemGroup>

</Project>

=== TableauExporterService\TableauExporterService.API\ProductReviewAnalyzer.TableauExporterService.API.csproj.user ===

<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ActiveDebugProfile>Container (Dockerfile)</ActiveDebugProfile>
  </PropertyGroup>
</Project>

=== TableauExporterService\TableauExporterService.API\Program.cs ===

using MassTransit;
using Microsoft.Extensions.Diagnostics.HealthChecks;
using MongoDB.Driver;
using ProductReviewAnalyzer.TableauExporterService.Features.PubSub.Consumers;
using ProductReviewAnalyzer.TableauExporterService.Infrastructure;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddInfrastructure(builder.Configuration);

builder.Services.AddMassTransit(x =>
{
    x.SetKebabCaseEndpointNameFormatter();
    x.AddConsumer<AnalysisCompletedConsumer>();

    x.UsingRabbitMq((ctx, cfg) =>
    {
        cfg.Host(builder.Configuration.GetConnectionString("RabbitMQ")
                 ?? throw new InvalidOperationException("RabbitMQ connection string not configured"));
        cfg.ConfigureEndpoints(ctx);
    });
});

builder.Services.AddSingleton<IMongoClient>(sp =>
    new MongoClient(builder.Configuration.GetConnectionString("Mongo")!));

builder.Services
    .AddHealthChecks()
    .AddMongoDb(
        clientFactory: sp => sp.GetRequiredService<IMongoClient>(),
        name: "mongo",
        failureStatus: HealthStatus.Unhealthy
    );

var app = builder.Build();

app.MapHealthChecks("/health");

app.Run();

=== TableauExporterService\TableauExporterService.API\Properties\launchSettings.json ===

{
  "profiles": {
    "http": {
      "commandName": "Project",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "dotnetRunMessages": true,
      "applicationUrl": "http://localhost:5004"
    },
    "https": {
      "commandName": "Project",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "dotnetRunMessages": true,
      "applicationUrl": "https://localhost:7284;http://localhost:5004"
    },
    "Container (Dockerfile)": {
      "commandName": "Docker",
      "launchUrl": "{Scheme}://{ServiceHost}:{ServicePort}",
      "environmentVariables": {
        "ASPNETCORE_HTTPS_PORTS": "8081",
        "ASPNETCORE_HTTP_PORTS": "8080"
      },
      "publishAllPorts": true,
      "useSSL": true
    }
  },
  "$schema": "https://json.schemastore.org/launchsettings.json"
}

=== TableauExporterService\TableauExporterService.Features\ProductReviewAnalyzer.TableauExporterService.Features.csproj ===

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="MassTransit" Version="8.4.1" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\Contracts\ProductReviewAnalyzer.Contracts.csproj" />
    <ProjectReference Include="..\TableauExporterService.Infrastructure\ProductReviewAnalyzer.TableauExporterService.Infrastructure.csproj" />
  </ItemGroup>

</Project>

=== TableauExporterService\TableauExporterService.Features\PubSub\DatasetBuilder.cs ===

using System.Text.Json;
using ProductReviewAnalyzer.Contracts;

namespace ProductReviewAnalyzer.TableauExporterService.Features.PubSub;

internal static class DatasetBuilder
{
    public static string Build(AnalysisCompleted evt)
    {
        var payload = new
        {
            evt.AnalysisId,
            evt.GoodsId,
            evt.Store,
            evt.ProductSentiment,
            evt.StoreSentiment,
            evt.ProductPros,
            evt.ProductCons,
            evt.ProductCategories,
            evt.StorePros,
            evt.StoreCons,
            evt.AnalyzedAtUtc
        };

        return JsonSerializer.Serialize(payload);
    }
}

=== TableauExporterService\TableauExporterService.Features\PubSub\Consumers\AnalysisCompletedConsumer.cs ===

using MassTransit;
using Microsoft.Extensions.Logging;
using ProductReviewAnalyzer.Contracts;
using ProductReviewAnalyzer.TableauExporterService.Infrastructure.Logging;
using ProductReviewAnalyzer.TableauExporterService.Infrastructure.Tableau;

namespace ProductReviewAnalyzer.TableauExporterService.Features.PubSub.Consumers;

public sealed class AnalysisCompletedConsumer(
    ITableauService tableau,
    ILogRepository loggerRepo,
    ILogger<AnalysisCompletedConsumer> logger)
    : IConsumer<AnalysisCompleted>
{
    public async Task Consume(ConsumeContext<AnalysisCompleted> ctx)
    {
        var evt = ctx.Message;
        logger.LogInformation("Exporting analysis {Id} to Tableau", evt.AnalysisId);

        var dataset = DatasetBuilder.Build(evt);

        try
        {
            await tableau.PushDatasetAsync("ProductReview", "ReviewAnalyses", dataset, ctx.CancellationToken);

            await loggerRepo.InsertAsync(new LogEntry
            {
                AnalysisId = evt.AnalysisId,
                Result = "Success"
            }, ctx.CancellationToken);
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Failed to export {Id}", evt.AnalysisId);

            await loggerRepo.InsertAsync(new LogEntry
            {
                AnalysisId = evt.AnalysisId,
                Result = "Failure",
                Details = ex.Message
            }, ctx.CancellationToken);

            throw;
        }
    }
}

=== TableauExporterService\TableauExporterService.Infrastructure\InfrastructureDependencyInjection.cs ===

using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using ProductReviewAnalyzer.TableauExporterService.Infrastructure.Logging;
using ProductReviewAnalyzer.TableauExporterService.Infrastructure.Tableau;

namespace ProductReviewAnalyzer.TableauExporterService.Infrastructure;

public static class InfrastructureDependencyInjection
{
    public static IServiceCollection AddInfrastructure(this IServiceCollection services, IConfiguration cfg)
    {
        services.AddHttpClient<ITableauService, TableauService>(client =>
        {
            client.BaseAddress = new Uri(cfg["Tableau:BaseUrl"] ?? "https://tableau.example.com");
            client.DefaultRequestHeaders.Add("X-Tableau-Auth", cfg["Tableau:ApiToken"]);
        });

        services.AddSingleton<ILogRepository, MongoLogRepository>();

        return services;
    }
}

=== TableauExporterService\TableauExporterService.Infrastructure\ProductReviewAnalyzer.TableauExporterService.Infrastructure.csproj ===

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Configuration" Version="9.0.5" />
    <PackageReference Include="Microsoft.Extensions.Http" Version="9.0.5" />
    <PackageReference Include="Microsoft.Extensions.Logging" Version="9.0.5" />
    <PackageReference Include="MongoDB.Driver" Version="3.4.0" />
    <PackageReference Include="Polly" Version="8.5.2" />
  </ItemGroup>

</Project>

=== TableauExporterService\TableauExporterService.Infrastructure\Logging\ILogRepository.cs ===

namespace ProductReviewAnalyzer.TableauExporterService.Infrastructure.Logging;

public interface ILogRepository
{
    Task InsertAsync(LogEntry entry, CancellationToken ct);
}

=== TableauExporterService\TableauExporterService.Infrastructure\Logging\LogEntry.cs ===

namespace ProductReviewAnalyzer.TableauExporterService.Infrastructure.Logging;

public class LogEntry
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public Guid AnalysisId { get; init; }
    public DateTime CreatedAtUtc { get; init; } = DateTime.UtcNow;
    public string Result { get; init; } = default!;
    public string? Details { get; init; }
}

=== TableauExporterService\TableauExporterService.Infrastructure\Logging\MongoLogRepository.cs ===

using Microsoft.Extensions.Configuration;
using MongoDB.Driver;

namespace ProductReviewAnalyzer.TableauExporterService.Infrastructure.Logging;

internal sealed class MongoLogRepository : ILogRepository
{
    private readonly IMongoCollection<LogEntry> _col;
    public MongoLogRepository(IConfiguration cfg)
    {
        var cs = cfg.GetConnectionString("Mongo")
                 ?? throw new InvalidOperationException("Mongo connection string not configured");
        var db = new MongoClient(cs).GetDatabase("tableau_exporter");
        _col = db.GetCollection<LogEntry>("logs");
    }

    public Task InsertAsync(LogEntry entry, CancellationToken ct) =>
        _col.InsertOneAsync(entry, cancellationToken: ct);
}

=== TableauExporterService\TableauExporterService.Infrastructure\Tableau\ITableauService.cs ===

namespace ProductReviewAnalyzer.TableauExporterService.Infrastructure.Tableau;

public interface ITableauService
{
    Task PushDatasetAsync(string projectName, string datasourceName, string jsonDataset, CancellationToken ct);
}

=== TableauExporterService\TableauExporterService.Infrastructure\Tableau\TableauService.cs ===

using System.Net.Http.Json;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using Polly;
using Polly.Retry;

namespace ProductReviewAnalyzer.TableauExporterService.Infrastructure.Tableau;

internal sealed class TableauService : ITableauService
{
    private readonly HttpClient _http;
    private readonly ILogger<TableauService> _logger;
    private readonly string _siteId;
    private readonly AsyncRetryPolicy _policy;

    public TableauService(HttpClient http, IConfiguration cfg, ILogger<TableauService> logger)
    {
        _http = http;
        _logger = logger;
        _siteId = cfg["Tableau:SiteId"] ?? "";

        _policy = Policy
            .Handle<Exception>()
            .WaitAndRetryAsync(3, attempt => TimeSpan.FromSeconds(attempt * 2),
                (ex, ts, retry, ctx) =>
                {
                    _logger.LogWarning(ex,
                        "Error pushing to Tableau (attempt {Retry}/{Max})", retry, 3);
                });
    }

    public async Task PushDatasetAsync(
        string projectName,
        string datasourceName,
        string jsonDataset,
        CancellationToken ct)
    {
        await _policy.ExecuteAsync(async _ =>
        {
            var req = new
            {
                datasourceName,
                projectName,
                jsonDataset
            };

            var res = await _http.PostAsJsonAsync(
                $"/api/3.19/sites/{_siteId}/data", req, ct);

            res.EnsureSuccessStatusCode();
            _logger.LogInformation("Dataset for {DatasourceName} pushed to Tableau", datasourceName);
        }, ct);
    }
}

=== WebApp\App.razor ===

@using Microsoft.AspNetCore.Components.Routing

<Router AppAssembly="@typeof(Program).Assembly">
    <Found Context="routeData">
        <RouteView RouteData="@routeData" />
    </Found>
    <NotFound>
        <h3>–°—Ç–æ—Ä—ñ–Ω–∫—É –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ</h3>
    </NotFound>
</Router>

=== WebApp\appsettings.Development.json ===

{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}

=== WebApp\appsettings.json ===

{
  "ApiGateway": {
    "BaseUrl": null
  },
  "Tableau": {
    "DashboardUrl": null
  }
}

=== WebApp\Dockerfile ===

FROM mcr.microsoft.com/dotnet/aspnet:9.0 AS base
USER $APP_UID
WORKDIR /app


FROM mcr.microsoft.com/dotnet/sdk:9.0 AS build
ARG BUILD_CONFIGURATION=Release
WORKDIR /src
COPY ["WebApp/ProductReviewAnalyzer.WebApp.csproj", "WebApp/"]
COPY ["HistoryService/HistoryService.API/ProductReviewAnalyzer.HistoryService.API.csproj", "HistoryService/HistoryService.API/"]
COPY ["HistoryService/HistoryService.Application/ProductReviewAnalyzer.HistoryService.Application.csproj", "HistoryService/HistoryService.Application/"]
COPY ["HistoryService/HistoryService.Domain/ProductReviewAnalyzer.HistoryService.Domain.csproj", "HistoryService/HistoryService.Domain/"]
COPY ["HistoryService/HistoryService.Infrastructure/ProductReviewAnalyzer.HistoryService.Infrastructure.csproj", "HistoryService/HistoryService.Infrastructure/"]
COPY ["Common/ProductReviewAnalyzer.Common.csproj", "Common/"]
COPY ["ReviewsScraper.Rozetka/ProductReviewAnalyzer.ReviewsScraper.Rozetka.csproj", "ReviewsScraper.Rozetka/"]
COPY ["Contracts/ProductReviewAnalyzer.Contracts.csproj", "Contracts/"]
RUN dotnet restore "./WebApp/ProductReviewAnalyzer.WebApp.csproj"
COPY . .
WORKDIR "/src/WebApp"
RUN dotnet build "./ProductReviewAnalyzer.WebApp.csproj" -c $BUILD_CONFIGURATION -o /app/build

FROM build AS publish
ARG BUILD_CONFIGURATION=Release
RUN dotnet publish "./ProductReviewAnalyzer.WebApp.csproj" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "ProductReviewAnalyzer.WebApp.dll"]

=== WebApp\ProductReviewAnalyzer.WebApp.csproj ===

<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <UserSecretsId>07cf29cc-3f70-4870-8537-f0ca7732a097</UserSecretsId>
    <DockerDefaultTargetOS>Linux</DockerDefaultTargetOS>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="FluentValidation" Version="12.0.0" />
    <PackageReference Include="FluentValidation.AspNetCore" Version="11.3.0" />
    <PackageReference Include="Mapster" Version="7.4.0" />
    <PackageReference Include="Mapster.DependencyInjection" Version="1.0.1" />
    <PackageReference Include="MediatR" Version="12.5.0" />
    <PackageReference Include="Microsoft.AspNetCore.Components.WebAssembly" Version="9.0.5" />
    <PackageReference Include="Microsoft.VisualStudio.Azure.Containers.Tools.Targets" Version="1.21.0" />
    <PackageReference Include="Refit" Version="8.0.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\HistoryService\HistoryService.API\ProductReviewAnalyzer.HistoryService.API.csproj" />
    <ProjectReference Include="..\ReviewsScraper.Rozetka\ProductReviewAnalyzer.ReviewsScraper.Rozetka.csproj" />
  </ItemGroup>

</Project>

=== WebApp\ProductReviewAnalyzer.WebApp.csproj.DotSettings.user ===

<wpf:ResourceDictionary xml:space="preserve" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:s="clr-namespace:System;assembly=mscorlib" xmlns:ss="urn:shemas-jetbrains-com:settings-storage-xaml" xmlns:wpf="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
	<s:String x:Key="/Default/CodeInspection/WebPathMapping/IgnoredPaths/=WWWROOT_005C_005FFRAMEWORK/@EntryIndexedValue">wwwroot\_framework</s:String>
	
	<s:String x:Key="/Default/CodeInspection/WebPathMapping/PathsInCorrectCasing/=WWWROOT_005C_005FFRAMEWORK/@EntryIndexedValue">wwwroot\_framework</s:String></wpf:ResourceDictionary>

=== WebApp\ProductReviewAnalyzer.WebApp.csproj.user ===

<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ActiveDebugProfile>Container (Dockerfile)</ActiveDebugProfile>
    <RazorPage_SelectedScaffolderID>RazorPageScaffolder</RazorPage_SelectedScaffolderID>
    <RazorPage_SelectedScaffolderCategoryPath>root/Common/RazorPage</RazorPage_SelectedScaffolderCategoryPath>
  </PropertyGroup>
</Project>

=== WebApp\Program.cs ===

using Mapster;
using MapsterMapper;
using MediatR;
using FluentValidation;
using FluentValidation.AspNetCore;
using ProductReviewAnalyzer.WebApp.Services;
using ProductReviewAnalyzer.WebApp.Shared.Mapping;
using System.Reflection;
using Refit;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddMediatR(cfg => cfg.RegisterServicesFromAssembly(typeof(Program).Assembly));

var config = TypeAdapterConfig.GlobalSettings;
config.Apply(new MappingProfile());
builder.Services.AddSingleton(config);
builder.Services.AddScoped<IMapper, ServiceMapper>();

builder.Services.AddValidatorsFromAssembly(typeof(Program).Assembly);
builder.Services.AddFluentValidationAutoValidation();
builder.Services.AddFluentValidationClientsideAdapters();

builder.Services.AddRefitClient<IApiGatewayClient>()
    .ConfigureHttpClient(c => c.BaseAddress = new Uri(builder.Configuration["ApiGateway:BaseUrl"]!));

//builder.Services.AddScoped<IApiGatewayClient, ApiGatewayClient>();

builder.Services.AddRazorPages();
builder.Services.AddServerSideBlazor();

var app = builder.Build();

app.UseStaticFiles();
app.UseRouting();
app.MapBlazorHub();
app.MapFallbackToPage("/_Host");

app.Run();

=== WebApp\_Imports.razor ===

@using System.Net.Http
@using System.Threading.Tasks
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Web
@using MediatR
@using Mapster
@using MapsterMapper
@using ProductReviewAnalyzer.WebApp.Components
@using ProductReviewAnalyzer.WebApp.Services
@using ProductReviewAnalyzer.WebApp.Shared.Models
@using ProductReviewAnalyzer.WebApp.Shared.UI.Commands
@using ProductReviewAnalyzer.WebApp.Shared.UI.Handlers

=== WebApp\Components\AnalysisForm.razor ===

@inject IMediator Mediator

<EditForm Model="_model" OnValidSubmit="HandleSubmit">
    <DataAnnotationsValidator />
    <ValidationSummary />
    <InputText @bind-Value="_model.Url" placeholder="–í–≤–µ–¥—ñ—Ç—å URL —Ç–æ–≤–∞—Ä—É" class="form-control" />
    <button type="submit" class="btn btn-primary mt-2">–ê–Ω–∞–ª—ñ–∑—É–≤–∞—Ç–∏</button>
</EditForm>

@code {
    private AnalyzeRequestModel _model = new();

    private async Task HandleSubmit()
    {
        await Mediator.Send(new AnalyzeProductCommand(_model));
    }
}

=== WebApp\Components\HistoryList.razor ===

@inject IMediator Mediator

@if (_history is null)
{
    <p>–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —ñ—Å—Ç–æ—Ä—ñ—ó‚Ä¶</p>
}
else if (!_history.Any())
{
    <p>–Ü—Å—Ç–æ—Ä—ñ—è –ø–æ—Ä–æ–∂–Ω—è.</p>
}
else
{
    <table class="table">
        <thead>
        <tr>
            <th>URL</th>
            <th>–ß–∞—Å</th>
            <th>–°—Ç–∞—Ç—É—Å</th>
        </tr>
        </thead>
        <tbody>
        @foreach (var item in _history)
        {
            <tr>
                <td>@item.Url</td>
                <td>@item.RequestedAtUtc.ToLocalTime()</td>
                <td>@item.Status</td>
            </tr>
        }
        </tbody>
    </table>
}

@code {
    private List<HistoryRecordDto>? _history;

    protected override async Task OnInitializedAsync()
    {
        _history = await Mediator.Send(new GetHistoryQuery());
    }
}

=== WebApp\Components\TableauDashboard.razor ===

@code {
    [Parameter] public string DashboardUrl { get; set; } = "";
}
<iframe src="@DashboardUrl" style="width:100%;height:800px;border:none;"></iframe>

=== WebApp\Pages\Index.razor ===

@page "/"
@using ProductReviewAnalyzer.WebApp.Shared.Models
@inject IConfiguration Configuration

<h3>–ê–Ω–∞–ª—ñ–∑ –≤—ñ–¥–≥—É–∫—ñ–≤ —Ç–æ–≤–∞—Ä—É</h3>

<AnalysisForm />

<hr />

<h4>–Ü—Å—Ç–æ—Ä—ñ—è –∑–∞–ø–∏—Ç—ñ–≤</h4>
<HistoryList />

<hr />

<h4>Dashboard</h4>
<TableauDashboard DashboardUrl="@Configuration["Tableau:DashboardUrl"]" />

=== WebApp\Pages\_Host.cshtml ===

@page "/"
@namespace ProductReviewAnalyzer.WebApp.Pages
@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers
@{
    Layout = null;
}

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ProductReviewAnalyzer</title>
    <base href="~/" />
    <link href="lib/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet" />
    <link href="css/site.css" rel="stylesheet" />
</head>
<body>
<app>
    <component type="typeof(Pages.Index)" render-mode="ServerPrerendered" />
</app>

<script src="_framework/blazor.server.js"></script>
</body>
</html>

=== WebApp\Pages\_Host.cshtml.cs ===

using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.RazorPages;

namespace ProductReviewAnalyzer.WebApp.Pages
{
    public class _HostModel : PageModel
    {
        public void OnGet()
        {
        }
    }
}

=== WebApp\Properties\launchSettings.json ===

{
  "profiles": {
    "http": {
      "commandName": "Project",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "dotnetRunMessages": true,
      "applicationUrl": "http://localhost:5064"
    },
    "https": {
      "commandName": "Project",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "dotnetRunMessages": true,
      "applicationUrl": "https://localhost:7155;http://localhost:5064"
    },
    "Container (Dockerfile)": {
      "commandName": "Docker",
      "launchBrowser": true,
      "launchUrl": "{Scheme}://{ServiceHost}:{ServicePort}",
      "environmentVariables": {
        "ASPNETCORE_HTTPS_PORTS": "8081",
        "ASPNETCORE_HTTP_PORTS": "8080"
      },
      "publishAllPorts": true,
      "useSSL": true
    }
  },
  "$schema": "https://json.schemastore.org/launchsettings.json"
}

=== WebApp\Services\ApiGatewayClient.cs ===

using Refit;
using ProductReviewAnalyzer.WebApp.Shared.Models;

namespace ProductReviewAnalyzer.WebApp.Services;

public class ApiGatewayClient(IApiGatewayClient client) : IApiGatewayClient
{
    public Task<ApiResponse<object>> ScrapeAsync(AnalyzeRequestModel request)
        => client.ScrapeAsync(request);

    public Task<List<HistoryRecordDto>> GetHistoryAsync()
        => client.GetHistoryAsync();
}

=== WebApp\Services\IApiGatewayClient.cs ===

using Refit;
using ProductReviewAnalyzer.WebApp.Shared.Models;

namespace ProductReviewAnalyzer.WebApp.Services;

public interface IApiGatewayClient
{
    [Post("/api/scraper/rozetka/reviews")]
    Task<ApiResponse<object>> ScrapeAsync([Body] AnalyzeRequestModel request);

    [Get("/api/history")]
    Task<List<HistoryRecordDto>> GetHistoryAsync();
}

=== WebApp\Shared\Mapping\MappingProfile.cs ===

using Mapster;
using ProductReviewAnalyzer.WebApp.Shared.Models;

namespace ProductReviewAnalyzer.WebApp.Shared.Mapping;

public class MappingProfile : IRegister
{
    public void Register(TypeAdapterConfig config)
    {
        config.NewConfig<AnalyzeRequestModel, AnalyzeRequestModel>();
        config.NewConfig<HistoryRecordDto, HistoryRecordDto>();
    }
}

=== WebApp\Shared\Models\AnalyzeRequestModel.cs ===

using System.ComponentModel.DataAnnotations;

namespace ProductReviewAnalyzer.WebApp.Shared.Models;

public class AnalyzeRequestModel
{
    [Required(ErrorMessage = "URL –æ–±–æ–≤‚Äô—è–∑–∫–æ–≤–∏–π")]
    [Url(ErrorMessage = "–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç URL")]
    public string Url { get; set; } = string.Empty;
}

=== WebApp\Shared\Models\HistoryRecordDto.cs ===

namespace ProductReviewAnalyzer.WebApp.Shared.Models;

public record HistoryRecordDto(Guid Id, string Url, DateTime RequestedAtUtc, int Status);

=== WebApp\Shared\UI\Commands\AnalyzeProductCommand.cs ===

using MediatR;
using ProductReviewAnalyzer.WebApp.Shared.Models;

namespace ProductReviewAnalyzer.WebApp.Shared.UI.Commands;

public record AnalyzeProductCommand(AnalyzeRequestModel Request) : IRequest<Unit>;

=== WebApp\Shared\UI\Commands\GetHistoryQuery.cs ===

using MediatR;
using ProductReviewAnalyzer.WebApp.Shared.Models;

namespace ProductReviewAnalyzer.WebApp.Shared.UI.Commands;

public record GetHistoryQuery : IRequest<List<HistoryRecordDto>>;

=== WebApp\Shared\UI\Handlers\AnalyzeProductCommandHandler.cs ===

using MediatR;
using FluentValidation;
using ProductReviewAnalyzer.WebApp.Services;
using ProductReviewAnalyzer.WebApp.Shared.Models;
using ProductReviewAnalyzer.WebApp.Shared.UI.Commands;

namespace ProductReviewAnalyzer.WebApp.Shared.UI.Handlers;

public class AnalyzeProductCommandHandler(
    IApiGatewayClient api,
    IValidator<AnalyzeRequestModel> validator)
    : IRequestHandler<AnalyzeProductCommand, Unit>
{
    public async Task<Unit> Handle(AnalyzeProductCommand cmd, CancellationToken ct)
    {
        var model = cmd.Request;
        var validation = await validator.ValidateAsync(model, ct);
        if (!validation.IsValid)
            throw new ValidationException(validation.Errors);

        await api.ScrapeAsync(model);
        return Unit.Value;
    }
}

=== WebApp\Shared\UI\Handlers\GetHistoryQueryHandler.cs ===

using MediatR;
using ProductReviewAnalyzer.WebApp.Services;
using ProductReviewAnalyzer.WebApp.Shared.Models;
using ProductReviewAnalyzer.WebApp.Shared.UI.Commands;

namespace ProductReviewAnalyzer.WebApp.Shared.UI.Handlers;

public class GetHistoryQueryHandler(IApiGatewayClient api) : IRequestHandler<GetHistoryQuery, List<HistoryRecordDto>>
{
    public async Task<List<HistoryRecordDto>> Handle(GetHistoryQuery _, CancellationToken ct)
        => await api.GetHistoryAsync();
}

=== WebApp\Shared\Validators\AnalyzeRequestModelValidator.cs ===

using FluentValidation;
using ProductReviewAnalyzer.WebApp.Shared.Models;

namespace ProductReviewAnalyzer.WebApp.Shared.Validators;

public class AnalyzeRequestModelValidator : AbstractValidator<AnalyzeRequestModel>
{
    public AnalyzeRequestModelValidator()
    {
        RuleFor(x => x.Url)
            .NotEmpty().WithMessage("URL –Ω–µ –º–æ–∂–µ –±—É—Ç–∏ –ø–æ—Ä–æ–∂–Ω—ñ–º")
            .Must(u => Uri.IsWellFormedUriString(u, UriKind.Absolute))
            .WithMessage("–ù–µ–≤—ñ—Ä–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç URL");
    }
}

=== WebApp\wwwroot\css\site.css ===

body {
    font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    background-color: #f9f9f9;
    color: #333;
    margin: 0;
    padding: 0;
}

app {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
}

h3, h4 {
    font-weight: 600;
    margin-bottom: 1rem;
}

hr {
    border: none;
    border-top: 1px solid #ddd;
    margin: 2rem 0;
}

.analysis-form,
.history-list,
.dashboard-container {
    width: 100%;
    max-width: 800px;
    background-color: #fff;
    padding: 1.5rem;
    margin-bottom: 2rem;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
}

    .analysis-form .form-control {
        border-radius: 4px;
        box-shadow: none;
        border: 1px solid #ccc;
        transition: border-color 0.2s;
    }

        .analysis-form .form-control:focus {
            border-color: #007bff;
            box-shadow: 0 0 0 0.2rem rgba(0,123,255,0.25);
        }

    button.btn-primary {
        display: block;
        margin: 0 auto;
        width: 100%;
        border-radius: 4px;
        padding: 0.5rem;
        font-size: 1rem;
    }

    .history-list ul {
        list-style: none;
        padding: 0;
        margin: 0;
    }

    .history-list li {
        padding: 0.75rem 0;
        border-bottom: 1px solid #eee;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

        .history-list li:last-child {
            border-bottom: none;
        }

    .dashboard-container iframe {
        width: 100%;
        height: 800px;
        border: none;
        border-radius: 4px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    }

@media (max-width: 768px) {
    app {
        padding: 10px;
    }

    .analysis-form,
    .history-list,
    .dashboard-container {
        padding: 1rem;
        margin-bottom: 1.5rem;
    }
}